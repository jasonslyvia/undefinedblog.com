<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>undefined</title>
  
  <subtitle>everything starts &amp; ends</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://undefinedblog.com/"/>
  <updated>2017-04-23T13:08:17.000Z</updated>
  <id>https://undefinedblog.com/</id>
  
  <author>
    <name>jasonslyvia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何拦截 fetch 请求</title>
    <link href="https://undefinedblog.com/how-to-intercept-fetch/"/>
    <id>https://undefinedblog.com/how-to-intercept-fetch/</id>
    <published>2017-04-23T12:47:58.000Z</published>
    <updated>2017-04-23T13:08:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前端工程实践中，经常会有拦截 Ajax 请求的需求，比如统一添加 CSRF token，或者统一实现缓存处理等。在前 fetch 时代，如果使用了 jQuery，可以直接通过配置 <code>jQuery.ajaxPrefilter</code> 实现；如果用的是原生 API，也可以通过 hack XMLHttpRequest 完成同样的功能。</p><p>然而在 fetch API 出现后，事情就没那么简单了。在我上一篇文章<a href="https://undefinedblog.com/window-fetch-is-not-as-good-as-you-imagined/">《fetch 没有你想象的那么美》</a>中，我提到了对 fetch 进行 Monkey Patch 时遇到的奇怪报错：</p><blockquote><p>Uncaught TypeError: Already read</p></blockquote><p>同时解释了这是 fetch 使用 Stream API 导致的限制，那这是不是意味着我们无法 hack 原生的 fetch 从而实现对 fetch 结果的统一拦截过滤了呢？答案是否定的。</p><p>在仔细阅读完 fetch 相关的文档后，我在 <code>Response</code> 对象的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" target="_blank" rel="noopener">文档页面</a>找到了一个有意思的属性和一个更有意思的方法。</p><h3 id="Reponse-bodyUsed"><a href="#Reponse-bodyUsed" class="headerlink" title="Reponse.bodyUsed"></a>Reponse.bodyUsed</h3><p>这个属性用于标示这个 Response 对象是否已经被读取过，比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/api/user.json'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.bodyUsed); <span class="comment">// false</span></span><br><span class="line">  <span class="keyword">return</span> response.json().then(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.bodyUsed); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这里再次尝试对 response 的 Stream 数据进行读取，则会报错</span></span><br><span class="line">    <span class="comment">// response.text();   // Uncaught TypeError: Already read</span></span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拿到服务端响应的 JSON 对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>就很好的解释了 bodyUsed 属性的作用和使用方法。但是从实用角度来说，这个布尔值并没有太大的作用，真正帮我们解决拦截并统一响应 fetch 请求的功能在下面。</p><h3 id="Reponse-prototype-clone"><a href="#Reponse-prototype-clone" class="headerlink" title="Reponse.prototype.clone()"></a>Reponse.prototype.clone()</h3><p>这个 API 顾名思义就是对 response 对象的一个复制，根据 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/clone" target="_blank" rel="noopener">文档</a> 描述，复制出来的 response 对象和原来的对象数据和行为完全一致，只是保存在不同的变量中而已。</p><p>那么 clone 方法如何解决 Already Read 报错的问题呢，让我们稍微修改一下上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/api/user.json'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.bodyUsed); <span class="comment">// false</span></span><br><span class="line">  <span class="keyword">return</span> response.clone().json().then(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.bodyUsed); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这里再次尝试对 response 的 Stream 数据进行读取，没有问题</span></span><br><span class="line">    <span class="comment">// response.text().then(text =&gt; console.log(text));</span></span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意第 4 行我们在 <code>response.json()</code> 调用前添加了 <code>response.clone().json()</code>，这样就完成了对 response 对象的复制。后续的 Stream API 读取发生在一个全新的 response 对象上，所以原来的 response 对象 bodyUsed 属性为 false，也可以对其调用不同的读取方法，如 .text() 或 .blob()。</p><p>唯一需要注意的是，clone 方法的调用一定要发生在对 response 调用任何读取之前，比如下面的代码依然会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/api/user.json'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response.bodyUsed); <span class="comment">// false</span></span><br><span class="line">  <span class="keyword">return</span> response.json().then(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果这里先尝试 clone，再对 response 的 Stream 数据进行读取，依然会报错</span></span><br><span class="line">    <span class="comment">// response.clone().text().then(text =&gt; console.log(text));</span></span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前端工程实践中，经常会有拦截 Ajax 请求的需求，比如统一添加 CSRF token，或者统一实现缓存处理等。在前 fetch 时代，如果使用了 jQuery，可以直接通过配置 &lt;code&gt;jQuery.ajaxPrefilter&lt;/code&gt; 实现；如果用的是原生 A
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>fetch 没有你想象的那么美</title>
    <link href="https://undefinedblog.com/window-fetch-is-not-as-good-as-you-imagined/"/>
    <id>https://undefinedblog.com/window-fetch-is-not-as-good-as-you-imagined/</id>
    <published>2017-03-18T09:37:11.000Z</published>
    <updated>2017-03-18T12:25:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端工程中发送 HTTP 请求从来都不是一件容易的事，前有骇人的 <code>ActiveXObject</code>，后有 API 设计十分别扭的 <code>XMLHttpRequest</code>，甚至这些原生 API 的用法至今仍是很多大公司前端校招的考点之一。</p><p>也正是如此，fetch 的出现在前端圈子里一石激起了千层浪，大家欢呼雀跃弹冠相庆恨不得马上把项目中的 <code>$.ajax</code> 全部干掉。然而，在新鲜感过后， fetch 真的有你想象的那么美好吗？</p><blockquote><p>如果你还不了解 fetch，可以参考我的同事 @camsong 在 2015 年写的文章 <a href="https://github.com/camsong/blog/issues/2" target="_blank" rel="noopener">《传统 Ajax 已死，Fetch 永生》</a></p></blockquote><p>在开始「批斗」fetch之前，大家需要明确 fetch 的定位：<strong>fetch 是一个 low-level 的 API，它注定不会像你习惯的 <code>$.ajax</code> 或是 <code>axios</code> 等库帮你封装各种各样的功能或实现。</strong>也正是因为这个定位，在学习或使用 fetch API 时，你会遇到不少的挫折。</p><p>（对于没有耐心看完全文的同学，请先记住本文的主旨不在于批评 fetch，事实上 fetch 的出现绝对是前端领域的进步体现。在了解主旨的前提下，关注<strong>加黑</strong>部分即可。）</p><h2 id="发请求，比你想象的要复杂"><a href="#发请求，比你想象的要复杂" class="headerlink" title="发请求，比你想象的要复杂"></a>发请求，比你想象的要复杂</h2><p>很多人看到 fetch 的第一眼肯定会被它简洁的 API 吸引：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'http://abc.com/tiger.png'</span>);</span><br></pre></td></tr></table></figure><p>原来需要 <code>new XMLHttpRequest</code> 等小十行代码才能实现的功能如今一行代码就能搞定，能不让人动心吗！</p><p>但是当你真正在项目中使用时，少不了需要向服务端发送数据的过程，那么使用 fetch 发送一个对象到服务端需要几行代码呢？（出于兼容性考虑，大部分的项目在发送 POST 请求时都会使用 <code>application/x-www-form-urlencoded</code> 这种 <code>Content-Type</code>）</p><p>先来看看使用 jQuery 如何实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.post(<span class="string">'/api/add'</span>, &#123;<span class="attr">name</span>: <span class="string">'test'</span>&#125;);</span><br></pre></td></tr></table></figure><p>然后再看看 fetch 如何处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/api/add'</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">Object</span>.keys(&#123;<span class="attr">name</span>: <span class="string">'test'</span>&#125;).map(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(params[key]);</span><br><span class="line">  &#125;).join(<span class="string">'&amp;'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>等等，<code>body</code> 字段那一长串代码在干什么？<strong>因为 fetch 是一个 low-level 的 API，所以你需要自己 encode HTTP 请求的 payload，还要自己指定 HTTP Header 中的 <code>Content-Type</code> 字段。</strong></p><p>这样就结束了吗？如果你在自己的项目中这样发送 POST 请求，很可能会得到一个 <code>401 Unauthorized</code> 的结果（视你的服务端如何处理无权限的情况而定）。如果你在仔细看一遍文档，会发现<strong>原来  fetch 在发送请求时默认不会带上 Cookie！</strong></p><p>好，我们让 fetch 带上 Cookie：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/api/add'</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  credentials: <span class="string">'include'</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样，一个最基础的 POST 请求才算能够发出去。</p><p>同理，如果你需要 POST 一个 JSON 到服务端，你需要这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/api/add'</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  credentials: <span class="string">'include'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json;charset=UTF-8'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">'test'</span>&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>相比于 <code>$.ajax</code> 的封装，是不是复杂的不是一点半点呢？</p><h2 id="错误处理，比你想象的复杂"><a href="#错误处理，比你想象的复杂" class="headerlink" title="错误处理，比你想象的复杂"></a>错误处理，比你想象的复杂</h2><p>按理说，fetch 是基于 <code>Promise</code> 的 API，每个 fetch 请求会返回一个 Promise 对象，而 Promise 的异常处理且不论是否方便，起码大家是比较熟悉的了。然而 fetch 的异常处理，还是有不少门道。</p><p>假如我们用 fetch 请求一个不存在的资源：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'xx.png'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>按照我们的惯例 console 应该要打印出 「error」才对，可事实又如何呢？有图有真相：</p><p><img src="https://img.alicdn.com/tfs/TB1qBeJQXXXXXcoXpXXXXXXXXXX-1168-158.png" alt="fetch response ok fail"></p><p>为什么会打印出 「ok」呢？</p><p><strong>按照 MDN 的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful" target="_blank" rel="noopener">说法</a>，fetch 只有在遇到网络错误的时候才会 reject 这个 promise，比如用户断网或请求地址的域名无法解析等。只要服务器能够返回 HTTP 响应（甚至只是 CORS preflight 的 OPTIONS 响应），promise 一定是 resolved 的状态。</strong></p><p>所以要怎么判断一个 fetch 请求是不是成功呢？你得用 <code>response.ok</code> 这个字段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'xx.png'</span>)</span><br><span class="line">.then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再执行一次，终于看到了正确的日志：</p><p><img src="https://img.alicdn.com/tfs/TB1DmSmQXXXXXbcaXXXXXXXXXXX-1214-426.png" alt="fetch response ok success"></p><h2 id="Stream-API，比你想象的复杂"><a href="#Stream-API，比你想象的复杂" class="headerlink" title="Stream API，比你想象的复杂"></a>Stream API，比你想象的复杂</h2><p><strong>当你的服务端返回的数据是 JSON 格式时，你肯定希望 fetch 返回给你的是一个普通 JavaScript 对象，然而你拿到的是一个 <code>Response</code> 对象，而真正的请求结果 —— 即 <code>response.body</code> —— 则是一个 <code>ReadableStream</code>。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'/api/user.json?id=2'</span>)   <span class="comment">// 服务端返回 &#123;"name": "test", "age": 1&#125; 字符串</span></span><br><span class="line">.then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里拿到的 response 并不是一个 &#123;name: 'test', age: 1&#125; 对象</span></span><br><span class="line">  <span class="keyword">return</span> response.json();  <span class="comment">// 将 response.body 通过 JSON.parse 转换为 JS 对象</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// &#123;name: 'test', age: 1&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>你可能觉得，这些写在规范里的技术细节使用 fetch 的人无需关心，然而在实际使用过程中你会遇到各种各样的问题迫使你不得不了解这些细节。</p><p>首先需要承认，fetch 将 <code>response.body</code> 设计成 ReadableStream 其实是非常有前瞻性的，这种设计让你在请求大体积文件时变得非常有用。然而，在我们的日常使用中，还是短小的 JSON 片段更加常见。而为了兼容不常见的设计，我们不得不多一次 <code>response.json()</code> 的调用。</p><p>不仅是调用变得麻烦，如果你的服务端采用了严格的 REST 风格，<strong>对于某些特殊情况并没有返回 JSON 字符串，而是用了 HTTP 状态码（如：<code>204 No Content</code>），那么在调用 <code>response.json()</code> 时则会抛出异常。</strong></p><p>此外，<strong><code>Response</code> 还限制了响应内容的重复读取和转换</strong>，例如如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prevFetch = <span class="built_in">window</span>.fetch;</span><br><span class="line"><span class="built_in">window</span>.fetch = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  prevFetch.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      response.json().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.hasError === <span class="literal">true</span>) &#123;</span><br><span class="line">          tracker.log(<span class="string">'API Error'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(response);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'/api/user.json?id=1'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();  <span class="comment">// 先将结果转换为 JSON 对象</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>是对 fetch 做了一个简单的 AOP，试图拦截所有的请求结果，并当返回的 JSON 对象中 <code>hasError</code> 字段如果为 <code>true</code> 的话，打点记录出错的接口。</p><p>然而这样的代码会导致如下错误：</p><blockquote><p>Uncaught TypeError: Already read</p></blockquote><p>调试一番后，你会发现是因为我们在切面中已经调用了 <code>response.json()</code>，这个时候重复调用该方法时就会报错。（实际上，再次调用其它任何转换方法，如 <code>.text()</code> 也会报错）</p><p>因此，想要在 fetch 上实现 AOP 仍需另辟蹊径。</p><h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><p>1. fetch 不支持同步请求</p><p>大家都知道同步请求阻塞页面交互，但事实上仍有不少项目在使用同步请求，可能是历史架构等等原因。如果你切换了 fetch 则无法实现这一点。</p><p>2. fetch 不支持取消一个请求</p><p>使用 XMLHttpRequest 你可以用 <code>xhr.abort()</code> 方法取消一个请求（虽然这个方法也不是那么靠谱，同时是否真的「取消」还依赖于服务端的实现），但是使用 fetch 就无能为力了，至少目前是这样的。</p><p>3. fetch 无法查看请求的进度</p><p>使用 XMLHttpRequest 你可以通过 <code>xhr.onprogress</code> 回调来动态更新请求的进度，而这一点目前 fetch 还没有原生支持。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>还是要再次明确，fetch API 的出现绝对是推动了前端在请求发送功能方面的进步。</p><p>然而，也需要意识到，<strong>fetch 是一个相当底层的 API，在实际项目使用中，需要做各种各样的封装和异常处理，而并非开箱即用</strong>，更做不到直接替换 <code>$.ajax</code> 或其他请求库。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>fetch spec <a href="https://fetch.spec.whatwg.org/#body" target="_blank" rel="noopener">https://fetch.spec.whatwg.org/#body</a></li><li>fetch 实现 <a href="https://github.com/github/fetch" target="_blank" rel="noopener">https://github.com/github/fetch</a></li><li>什么是 Already Read 报错 <a href="http://stackoverflow.com/questions/34786358/what-does-this-error-mean-uncaught-typeerror-already-read" target="_blank" rel="noopener">http://stackoverflow.com/questions/34786358/what-does-this-error-mean-uncaught-typeerror-already-read</a></li><li>使用 fetch 处理 HTTP 请求失败 <a href="https://www.tjvantoll.com/2015/09/13/fetch-and-errors/" target="_blank" rel="noopener">https://www.tjvantoll.com/2015/09/13/fetch-and-errors/</a></li><li><a href="https://jakearchibald.com/2015/thats-so-fetch/" target="_blank" rel="noopener">https://jakearchibald.com/2015/thats-so-fetch/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端工程中发送 HTTP 请求从来都不是一件容易的事，前有骇人的 &lt;code&gt;ActiveXObject&lt;/code&gt;，后有 API 设计十分别扭的 &lt;code&gt;XMLHttpRequest&lt;/code&gt;，甚至这些原生 API 的用法至今仍是很多大公司前端校招的考点之一。&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mocha 测试设置 timeout 不生效的问题排查</title>
    <link href="https://undefinedblog.com/set-timeout-for-mocha-with-karma/"/>
    <id>https://undefinedblog.com/set-timeout-for-mocha-with-karma/</id>
    <published>2017-01-16T11:47:25.000Z</published>
    <updated>2017-01-16T11:56:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mocha 提供了针对不同粒度的测试超时配置项，但是最近在某个使用了 Karma + Mocha 的项目中遇到无论怎么设置 <code>this.timeout()</code> Mocha 都顽固的在 2000ms 时报超时错误的问题，经排查疑似为当 Mocha 和 Karma 一起使用时，需要通过 <code>karma.conf.js</code> 来配置 Mocha 超时时间。</p><p>当没有正确设置 Karma + Mocha 超时时间时，会报出如下错误：</p><blockquote><p>Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure “done()” is called; if returning a Promise, ensure it resolves.</p></blockquote><p>此时即使在测试代码里显式添加了超时配置也没有用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'Suite'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'Case'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.timeout(<span class="number">60000</span>); <span class="comment">// 无用</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里还需要注意，一些新手经常犯的错误为这里使用了 ES2015 的箭头函数，this 这个 context 发生了改变，导致超时配置不生效。</p><p>最后经过一番 Google，发现当 Mocha 和 Karma 一起使用时，要在 <code>karma.conf.js</code> 里对 Mocha 进行配置，配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// karma.conf.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  config.set(&#123;</span><br><span class="line">    client: &#123;</span><br><span class="line">      mocha: &#123;</span><br><span class="line">        timeout : <span class="number">6000</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其它需要传递给 Mocha 的参数也可以在这里配置。此处配置的超时时间为全局级别，因此设置时要考虑最长的 Case 需要的时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mocha 提供了针对不同粒度的测试超时配置项，但是最近在某个使用了 Karma + Mocha 的项目中遇到无论怎么设置 &lt;code&gt;this.timeout()&lt;/code&gt; Mocha 都顽固的在 2000ms 时报超时错误的问题，经排查疑似为当 Mocha 和 Ka
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactRouter 4 前瞻</title>
    <link href="https://undefinedblog.com/reactrouter-4-foresee/"/>
    <id>https://undefinedblog.com/reactrouter-4-foresee/</id>
    <published>2016-09-17T20:44:57.000Z</published>
    <updated>2016-09-17T22:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>要问用 React 技术栈的前端同学对哪个库的感情最复杂，恐怕非 ReactRouter 莫属了。早在 React 0.x 时代，ReactRouter 就凭借与 React 核心思想一致的声明式 API 获得了大量开发者的喜爱。后续更是并入 reactjs group 并有 React 核心开发成员参与，俨然是 React 官方路由套件一样的存在。</p><p>然而从 1.x 版本起，ReactRouter 的洪荒之力就开始慢慢爆发，目前最稳定的版本已经是  <code>2.8.1</code>，而下一个正式版本将是 —— 没错，正如你在标题里看到的那样 —— <code>4.0.0</code>。先收拾一下你崩溃的心情，让我们来看看这一切到底是怎么回事。</p><h2 id="ReactRouter-3-去哪儿了"><a href="#ReactRouter-3-去哪儿了" class="headerlink" title="ReactRouter 3 去哪儿了"></a>ReactRouter 3 去哪儿了</h2><p>从 <code>2.x</code> 直接跨入 <code>4.x</code>，ReactRouter 的 maintainer 数学还不至于那么差，那这一切都是为什么呢？事实上 <code>3.x</code> 版本相比于 <code>2.x</code> 并没有引入任何新的特性，只是将 <code>2.x</code> 版本中部分废弃 API 的 warning 移除掉而已。按照规划，没有历史包袱的新项目想要使用稳定版的 ReactRouter 时，应该使用 ReactRouter 3.x。</p><p>目前 <code>3.x</code> 版本也还处于 beta 阶段，不过会先于 <code>4.x</code> 版本正式发布。<strong>如果你已经在使用 <code>2.x</code> 的版本，那么升级 <code>3.x</code> 将不会有任何额外的代码变动。</strong></p><h2 id="为什么又要大改-API"><a href="#为什么又要大改-API" class="headerlink" title="为什么又要大改 API"></a>为什么又要大改 API</h2><p>ReactRouter 的 API 是出了名的善变，这一点我已经在<a href="https://undefinedblog.com/react-v0-14/">之前的博文</a>中吐槽过一次了。没想到连 React 都稳定的在 <code>15.x</code> 版本中维护了这么久，ReactRouter 还是想要搞点大新闻。</p><p>根据 ReactRouter 核心开发者 <a href="https://github.com/ryanflorence" target="_blank" rel="noopener">ryanflorence</a> 的说法，ReactRouter 4.x 之所以要大刀阔斧的修改 API，主要是为了『声明式的可组合性（Declarative Composability）』。怎么理解声明式的可组合性呢？实际上当你在写 React 组件时，就不知不觉的利用了这一特性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComponentA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;A&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComponentB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;B&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;&lt;ComponentA /&gt;&lt;ComponentB /&gt;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上面的代码片段，在 Page 组件中你可以方便的将任意组件在 render 方法中渲染出来。但是这种特性遇到 ReactRouter 时，你只能把匹配当前路由的组件用<code>this.props.children</code>（最早的时候是 <code>this.props.routerHandler</code>，有多少人还有印象）渲染 。</p><p>此外，ReactRouter 虽然宣称是声明式的路由库，但仍然提供了不少非声明式的 API，其中路由组件的生命周期方法就是最典型的例子。其实我们不难想到，明明用来渲染的 React 组件本身已经有了一套完备的生命周期方法（componentWillMount、componentWillUnmount 等），为什么还需要 ReactRouter 提供的什么 <code>onEnter</code> 和 <code>onLeave</code> 呢？</p><p>当然，这一切都是 ryanflorence 个人的说法，不知道又有多少人真的会为了追求纯正的 declarative 花时间去重构代码兼容 ReactRouter 4 呢？</p><h2 id="ReactRouter-4-有什么变化"><a href="#ReactRouter-4-有什么变化" class="headerlink" title="ReactRouter 4 有什么变化"></a>ReactRouter 4 有什么变化</h2><p>虽然目前还是 alpha 版本，但是 ReactRouter 4 的 API 已经有了雏形，其<a href="https://react-router-website-xvufzcovng.now.sh/" target="_blank" rel="noopener">官方文档</a>也有不少带 demo 的例子，下面简单总结一下 ReactRouter 4 的变化。</p><h3 id="更少的-API"><a href="#更少的-API" class="headerlink" title="更少的 API"></a>更少的 API</h3><p>先来看看目前 ReactRouter 2 的 API 列表：</p><p><img src="http://ww3.sinaimg.cn/mw690/831e9385gw1f7xaeadze7j209d0j5t9v.jpg" alt="ReactRouter 2.x API 列表"></p><p>再看看 4.x 计划中的 API：</p><p><img src="http://ww3.sinaimg.cn/mw690/831e9385gw1f7xaf8ju4lj204406f3yj.jpg" alt="ReactRouter 4.x API 列表"></p><p>直观看起来 API 确实少了不少，但这也意味着使用了被废弃的 API 将会有更大的重构工作量。不，实际上即使用了没有被废弃的 API，也会有很大的重构工作量。但是对于新手来说，学习成本相对会比较低。</p><h3 id="lt-Router-gt-变身为容器"><a href="#lt-Router-gt-变身为容器" class="headerlink" title="&lt;Router&gt;变身为容器"></a>&lt;Router&gt;变身为容器</h3><p>在目前的 API 中，&lt;Router&gt; 组件的 children 只能是 ReactRouter 提供的各种组件，如 <code>&lt;Route&gt;、&lt;IndexRoute&gt;、&lt;Redirect&gt;</code>等。而在 ReactRouter 4 中，你可以将各种组件及标签放进 <code>&lt;Router&gt;</code> 组件中，他的角色也更像是 Redux 中的 <code>&lt;Provider&gt;</code>。</p><p>不同的是 <code>&lt;Provider&gt;</code> 是用来保持与 store 的更新，而 <code>&lt;Router&gt;</code> 是用来保持与 location 的同步。</p><p>以下为新版 ReactRouter 可能的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;Accounts&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;&lt;Link to="/</span>netflix<span class="string">"&gt;Netflix&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;Link to="</span>/zillow-group<span class="string">"&gt;Zillow Group&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;Link to="</span>/yahoo<span class="string">"&gt;Yahoo&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;Link to="</span>/modus-create<span class="string">"&gt;Modus Create&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;Match pattern="</span>/:id<span class="string">" component=&#123;Child&#125; /&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/Router&gt;</span></span><br></pre></td></tr></table></figure><p><strong>不过这样的变动将会导致一个很严重的问题：由于路由定义里不再是纯粹的路由相关的组件，你无法在一个文件中（通常是用来定义路由的 <code>routes.js</code>）看到整个 App 的路由设计及分布。</strong></p><p>目前 ReactRouter 提供了一个<a href="https://github.com/ReactTraining/react-router-addons-routes" target="_blank" rel="noopener">工具库</a>来解决将完整的路由定义转换为 <code>&lt;Match&gt;</code> 组件的问题，但是粗略的看了一下用法感觉还是比较别扭，期待正式发布时能有更好的解决方案。</p><h3 id="再见-lt-Route-gt-，你好-lt-Match-gt"><a href="#再见-lt-Route-gt-，你好-lt-Match-gt" class="headerlink" title="再见 &lt;Route&gt;，你好&lt;Match&gt;"></a>再见 &lt;Route&gt;，你好&lt;Match&gt;</h3><p>ReactRouter 中被使用最多的 <code>&lt;Route&gt;</code> 组件这次没有幸免，取而代之的是 <code>&lt;Match&gt;</code> 组件。那么 <code>&lt;Match&gt;</code> 究竟有什么不同呢？</p><p>1. <code>pattern</code> 取代 <code>path</code></p><p>很大程度上这只是为了配合 Match 这个名称的转换而已，实际功能与 path 无异。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Match pattern=<span class="string">"/users/:id"</span> component=&#123;User&#125;/&gt;</span><br></pre></td></tr></table></figure><p>2. <code>component</code> 还是 <code>component</code>，<code>components</code> 没了</p><p>判断路由命中时该渲染哪个组件的 props 还是叫 <code>component</code>，但是为一个路由同时提供多个命名组件的 props <code>components</code> 没有了。下文会详细介绍在 ReactRouter 中如何解决一个路由下渲染多个组件的问题。</p><p>3. 使用 <code>render</code> 渲染行内路由组件</p><p>能够更自由的控制当前命中组件的渲染，以及可以方便的添加进出的动画。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// convenient inline rendering</span></span><br><span class="line">&lt;Match pattern=<span class="string">"/home"</span> render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrapping/composing</span></span><br><span class="line"><span class="keyword">const</span> MatchWithFade = <span class="function">(<span class="params">&#123; component:Component, ...rest &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;Match &#123;...rest&#125; render=&#123;(matchProps) =&gt; (</span><br><span class="line">    &lt;FadeIn&gt;</span><br><span class="line">      &lt;Component &#123;...matchProps&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/FadeIn&gt;</span></span><br><span class="line"><span class="regexp">  )&#125;/</span>&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&lt;MatchWithFade pattern=<span class="string">"/cool"</span> component=&#123;Something&#125;/&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-Miss-gt-取代曾经的-lt-NotFoundRoute-gt"><a href="#lt-Miss-gt-取代曾经的-lt-NotFoundRoute-gt" class="headerlink" title="&lt;Miss&gt; 取代曾经的 &lt;NotFoundRoute&gt;"></a>&lt;Miss&gt; 取代曾经的 &lt;NotFoundRoute&gt;</h3><p>早在 0.x 时代，ReactRouter 提供了 <code>&lt;NotFountRoute&gt;</code> 来解决渲染 404 页面的问题。不过这一组件在 <code>1.x</code> 时就被移除了，你不得不多写若干行代码来解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果想要展示一个 404 页面（当前 URL 不变）</span></span><br><span class="line">&lt;Route path=<span class="string">'*'</span> component=&#123;My404Component&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想要展示一个 404 页面（当前 URL 重定向到 /404 ）</span></span><br><span class="line">&lt;Route path=<span class="string">'/404'</span> component=&#123;My404Component&#125; /&gt;</span><br><span class="line">&lt;Redirect <span class="keyword">from</span>=<span class="string">'*'</span> to=<span class="string">'/404'</span> /&gt;</span><br></pre></td></tr></table></figure><p>在 ReactRouter 4 中，你可以省点儿事直接用 <code>&lt;Miss&gt;</code> 组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Match pattern=<span class="string">"/foo"</span>/&gt;</span><br><span class="line">    &lt;Match pattern=<span class="string">"/bar"</span>/&gt;</span><br><span class="line">    &lt;Miss component=&#123;NoMatch&#125;/&gt;</span><br><span class="line">  &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const NoMatch = (&#123; location &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;Nothing matched &#123;location.pathname&#125;.&lt;/</span>div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="ReactRouter-4-的大杀器：一个路由，多次匹配"><a href="#ReactRouter-4-的大杀器：一个路由，多次匹配" class="headerlink" title="ReactRouter 4 的大杀器：一个路由，多次匹配"></a>ReactRouter 4 的大杀器：一个路由，多次匹配</h2><p>在上文中我们提到过，目前 ReactRouter 匹配到某个路由时，将直接渲染通过 <code>component</code> 定义的组件，并把命中的子路由对应的组件作为 <code>this.props.children</code> 传入。</p><p>在前端 App 日益复杂的今天，一条路由的改变不仅仅简单的是页面的切换，甚至可能精细到页面上某些组件的切换。</p><p>让我们直接看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每条路由有两个组件，一个用于渲染 sidebar，一个用于渲染主页面</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">pattern</span>: <span class="string">'/'</span>,</span><br><span class="line">    exactly: <span class="literal">true</span>,</span><br><span class="line">    sidebar: <span class="function"><span class="params">()</span> =&gt;</span> &lt;div&gt;Home!&lt;/div&gt;,</span><br><span class="line">    main: <span class="function"><span class="params">()</span> =&gt;</span> &lt;h2&gt;Main&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  &#123; pattern: '/</span>foo<span class="string">',</span></span><br><span class="line"><span class="string">    sidebar: () =&gt; &lt;div&gt;foo!&lt;/div&gt;,</span></span><br><span class="line"><span class="string">    main: () =&gt; &lt;h2&gt;Foo&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &#123; pattern: '</span>/bar<span class="string">',</span></span><br><span class="line"><span class="string">    sidebar: () =&gt; &lt;div&gt;Bar!&lt;/div&gt;,</span></span><br><span class="line"><span class="string">    main: () =&gt; &lt;h2&gt;Bar&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;Router history=&#123;history&#125;&gt;</span></span><br><span class="line"><span class="string">  &lt;div className="page"&gt;</span></span><br><span class="line"><span class="string">    &lt;div className="sidebar"&gt;</span></span><br><span class="line"><span class="string">      &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="/foo"&gt;Foo&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="/bar"&gt;Bar&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      /* 对当前路由进行匹配，并渲染侧边栏 */</span></span><br><span class="line"><span class="string">      &#123;routes.map((route, index) =&gt; (</span></span><br><span class="line"><span class="string">        &lt;Match</span></span><br><span class="line"><span class="string">          key=&#123;index&#125;</span></span><br><span class="line"><span class="string">          pattern=&#123;route.pattern&#125;</span></span><br><span class="line"><span class="string">          component=&#123;route.sidebar&#125;</span></span><br><span class="line"><span class="string">          exactly=&#123;route.exactly&#125;</span></span><br><span class="line"><span class="string">        /&gt;</span></span><br><span class="line"><span class="string">      ))&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;div className="main"&gt;</span></span><br><span class="line"><span class="string">      /* 对当前路由进行匹配，并渲染主界面 */</span></span><br><span class="line"><span class="string">      &#123;routes.map((route, index) =&gt; (</span></span><br><span class="line"><span class="string">        &lt;Match</span></span><br><span class="line"><span class="string">          key=&#123;index&#125;</span></span><br><span class="line"><span class="string">          pattern=&#123;route.pattern&#125;</span></span><br><span class="line"><span class="string">          component=&#123;route.main&#125;</span></span><br><span class="line"><span class="string">          exactly=&#123;route.exactly&#125;</span></span><br><span class="line"><span class="string">        /&gt;</span></span><br><span class="line"><span class="string">      ))&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/Router&gt;</span></span><br></pre></td></tr></table></figure><p>通过上面的代码片段我们可以看出，<code>&lt;Match&gt;</code> 的设计理念完全不同于 <code>&lt;Route&gt;</code>。使用 <code>&lt;Match&gt;</code> 可以让我们在当前路由中尽情的匹配并渲染需要的组件，无论是需要渲染 Sidebar、BreadCrumb 还是主界面。</p><p>若使用现有的 ReactRouter API，只能通过当前路由匹配主界面对应的组件，至于 Sidebar 和 BreadCrumb，只能传入当前的 pathname 手动进行匹配。由此可见 <code>&lt;Match&gt;</code> 将会为此类需求带来极大的便利。</p><h2 id="其他疑惑"><a href="#其他疑惑" class="headerlink" title="其他疑惑"></a>其他疑惑</h2><p>当然，还有几个大家普遍关心的问题官方文档中也有所提及：</p><p>1. ReactRouter 的 API 是否还会有大的变化？</p><p>答：只要 React 的 API 不变，这一版的 API 也不会变。</p><p>2. 是否有对 Redux 的支持？</p><p>答：将提供一个受控的 <code>&lt;ControlledRouter&gt;</code>，支持传入一个 location。（作者注：这下真的不需要 react-router-redux 了，撒花！）</p><p>3. 新版是否对滚动位置管理添加支持？</p><p>答：将会对 <code>window</code> 和独立组件的滚动位置提供管理功能。（作者注：目前在不添加额外配置的情况下，路由切换时并不会恢复滚动位置）</p><h2 id="ReactRouter-4-小结"><a href="#ReactRouter-4-小结" class="headerlink" title="ReactRouter 4 小结"></a>ReactRouter 4 小结</h2><p>了解了这么多 ReactRouter 4 的内容，你是否喜欢新版的 API 设计呢？</p><p>其实从 ReactRouter 4 的这些变动不难看出，ReactRouter 正在努力的朝纯声明式的 API 方向迈进，一方面减少不必要的命令式 API，一方面也提供更语义化的路由匹配方案。</p><p>此外新的 ReactRouter 也提供了非常强大的动态路由能力，甚至对嵌套路由也有所支持，这也是一个复杂的前端应用所必须的功能。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://react-router-website-xvufzcovng.now.sh/" target="_blank" rel="noopener">ReactRouter 4 文档</a></li><li><a href="https://github.com/ReactTraining/react-router/tree/v4" target="_blank" rel="noopener">ReactRouter 4 Github repo</a></li><li><a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">ReactRouter</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要问用 React 技术栈的前端同学对哪个库的感情最复杂，恐怕非 ReactRouter 莫属了。早在 React 0.x 时代，ReactRouter 就凭借与 React 核心思想一致的声明式 API 获得了大量开发者的喜爱。后续更是并入 reactjs group 并
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Angular2 中那些我看不懂的地方</title>
    <link href="https://undefinedblog.com/angular-the-confusing-part/"/>
    <id>https://undefinedblog.com/angular-the-confusing-part/</id>
    <published>2016-04-17T02:17:56.000Z</published>
    <updated>2016-05-01T12:01:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客停更了近 3 个月，实在是愧对很多在微博上推荐的同学。因为最近大部分时间都投入在公司里一个比较复杂的项目中，直到本周才算正式发布，稍得解脱。</p><p>说这个项目复杂，不仅是因为需求设计复杂，更是因为在这个项目里我们使用了很多新技术 —— Angular2（是的，beta 版），Webpack2（是的，beta 版），RxJS（这两个 <a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="noopener">RxJS1</a>、<a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="noopener">RxJS2</a> 傻傻分不清楚）还有 TypeScript。</p><p>关于为什么一个大型线上项目会选择这么冒进的技术选型这里不多做评价，只能说最终团队还是成功将整个产品发布到了线上，我也对 Angular2 这个全新的 Angular 有了更全面的认识。</p><p>这篇文章不想对比 React 和 Angular2（不要急，这些东西肯定会出现在项目总结里），而是想站在熟悉 React + Redux 开发模式的前端工程师角度说一说 Angular2，尤其是那些我不太理解的地方。</p><p>剧透：这篇文章无意引起骂战，因此如果你看到我哪里写的不对，请直接在评论区里纠正。</p><h2 id="看不懂的依赖注入"><a href="#看不懂的依赖注入" class="headerlink" title="看不懂的依赖注入"></a>看不懂的依赖注入</h2><p>我知道这其实不仅仅针对 Angular2，早在 Angular1 中就存在依赖注入的概念，甚至这还是 Angular 引以为傲的特性。每当谈到依赖注入的时候，我就看到一帮 OOP（以 Java 为首）爱好者眼里闪烁着奇异的光芒。</p><p>然而依赖注入的问题一直困扰着我，倒不是说不理解依赖注入的使用方法或是原理，而是不理解<strong>为什么我的代码里需要依赖注入？</strong></p><p>当我把这个问题抛给项目组中强推 Angular 的同学时，他也一时语塞。</p><p>在 Angular2 中，一个常见的依赖注入是注入一个 Http 对象，用于发送请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component, OnInit&#125; <span class="keyword">from</span> <span class="string">'angular2/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Http&#125; <span class="keyword">from</span> <span class="string">'angular2/http'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'test'</span>,</span><br><span class="line">  providers: [Http]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(private http: Http) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.http.get(<span class="string">'/api/user.json'</span>).map(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).subscribe(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这里拿到请求的结果</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是在 Angular 中使用内置 Http 模块发送请求的一段示例代码。具体依赖注入发生在 constructor 函数中。按照 Angular 宣传的那样，你只用简单的在 constructor 中声明这些参数，Angular 将自动为你处理依赖注入的问题。</p><p>注意到我们要使用 Http 来发请求，首先需要从 <code>angular2/http</code> 中将 Http import 进来，然后需要在组件的配置中添加对应的 providers，最后还需要在 constructor 中声明一个参数。</p><p>这个时候我其实是有点懵逼的，因为在一般应用里，发请求大概是这样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'superagent'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request.get(<span class="string">'/api/user.json'</span>).end(<span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是拿到请求的结果</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了公平起见，我还是假装依赖了一个第三方的库来实现 Ajax 请求。在这份代码里没有什么高大上的依赖注入，更没有什么 constructor，只有简单的引入并使用。</p><p>所以我不太明白，Angular 中的依赖注入究竟在多大程度上发挥着作用？</p><h3 id="语法糖、语法糖和语法糖"><a href="#语法糖、语法糖和语法糖" class="headerlink" title="语法糖、语法糖和语法糖"></a>语法糖、语法糖和语法糖</h3><p>很多人在第一眼看到 React 的时候，都在叫嚣 JSX 是「在 JS 里嵌入 HTML」，是邪门歪道，吃枣药丸。我只想说，相比于 Angular2 里的这些语法糖，JSX 简直就是 JavaScript 里的纯情小处男。</p><p>以下引用部分 Angular2 文档中关于模板语法的部分：</p><blockquote><p>Expanding *ngFor</p><p>The <em>ngFor undergoes a similar transformation. We begin with an </em>ngFor example:</p><p><code>&amp;lt;hero-detail *ngFor=&quot;#hero of heroes; trackBy:trackByHeroes&quot; [hero]=&quot;hero&quot;&gt;&lt;/hero-detail&gt;</code></p><p>Here’s the same example after transporting the ngFor to the template directive:</p><p><code>&amp;lt;hero-detail template=&quot;ngFor #hero of heroes; trackBy:trackByHeroes&quot; [hero]=&quot;hero&quot;&gt;&lt;/hero-detail&gt;</code></p><p>And here it is expanded further into a &lt;template&gt; tag wrapping the original &lt;hero-detail&gt; element:</p><p><code>&amp;lt;template ngFor #hero [ngForOf]=&quot;heroes&quot; [ngForTrackBy]=&quot;trackByHeroes&quot;&gt;  &lt;hero-detail [hero]=&quot;hero&quot;&gt;&lt;/hero-detail&gt;&amp;lt;/template&gt;</code></p></blockquote><p>读完之后你会发现，<code>*ngFor</code> 这个指令，原来是个语法糖。好嘛，其实语法糖在很多框架设计里都有啊。但是当你展开这个语法糖之后，你会发现这个语法糖其实还是另一个语法的语法糖。这也就是说，<code>*ngFor</code> 是语法糖的语法糖。</p><p>这种例子在 Angular2 中还有不少，任何一个正常的 JavaScript 开发者如果不想把自己逼疯的话，都会喜欢一个原始的 for 循环，或者一个 <code>[].map</code> 吧……</p><p>看到某篇文章争论说 Angular2 的模板用的是 「Valid HTML」，我只想说管你 Valid 不 Valid，臣妾看不懂啊。</p><h3 id="模板里面到底发生了什么"><a href="#模板里面到底发生了什么" class="headerlink" title="模板里面到底发生了什么"></a>模板里面到底发生了什么</h3><p>其实刚开始写 Angular 应用的时候，心里还是对双向绑定挺期待的。因为在 React + Redux 架构里面，表单处理永远都是一个痛点（这里安利一下自己写的 <a href="https://github.com/jasonslyvia/redux-form-utils" target="_blank" rel="noopener">redux-form-utils</a> 良心工具，线上产品背书）。但是等我真的在写 Component 中的 template 时，就开始慢慢崩溃了。</p><p>首先最崩溃的是，我没办法在模板中断点调试（还是我没有找到正确的方法），这导致在一些模板中存在复杂逻辑的场景我只能默默的在心里推倒运行的过程。</p><p>然后是在模板里面，你还是可以写大量的逻辑，比如这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;ul #listEl [class.rendered]="listEl.rendered"&gt;</span></span><br><span class="line"><span class="string">      &lt;li *ngFor="#item of list; if(last) &#123;listEl.rendered = true;&#125;" (click)="list.push(Math.random()); $event.stopPropagation(); $event.preventDefault(); // Do other fancy stuff"&gt;</span></span><br><span class="line"><span class="string">        &#123;&#123; item.text &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这些在模板中的代码都是完全合法的 Angular2 语法。有人可能觉得，允许你这么写不代表你一定要这么写。事实上，我已开始很多组件都是这么写的，因为很快，因为网上很多 demo 也这么写，因为不知道该怎么更好的组织代码。</p><p>这样下去，一个 Angular 组件中，你不仅要阅读组件本身的各种对数据的处理，还要看模板中的各种逻辑。尤其是一些比较复杂的组件，模板和组件本身放在不同的文件中时，这种来回上下文的切换真是酸爽。</p><h3 id="组件通信操碎了心"><a href="#组件通信操碎了心" class="headerlink" title="组件通信操碎了心"></a>组件通信操碎了心</h3><p>在 Angular 中，父组件想要传递一些信息给子组件，还是比较简单的，直接使用属性绑定即可。在子组件中稍微麻烦一点，多声明一个 @Input。</p><blockquote><p>这里还想吐槽两句，一个组件想要引用另一个组件，要先 import 进来，然后还要加到当前组件 Component 配置的 directives 属性中。开发过程中好多次莫名其妙的报错都是因为忘了这一步……</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.js</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'parent'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Parent&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;child [data]="data"&gt;&lt;/child&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  data = <span class="string">'react'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.js</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'child'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h4&gt;Child&lt;/h4&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Data from parent: &#123;&#123; data &#125;&#125;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">  @Input() data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候问题来了，当子组件发生某些变化父组件想要知道的时候，你有这么几种选择。</p><ol><li>在子组件中定一个 @Output 属性，然后父组件用 (event)=”handler()” 的语法来监听这个事件</li><li>将父组件的一个 event handler 当做属性传给子组件，子组件通过调用这个方法来通知父组件（在 Redux 里，这很常见）</li><li>设计一个 Service 然后分别注入到父组件和子组件之中进行通信</li></ol><p>在我开发这个项目的时候，Angular2 的官方文档中还没有任何教程说明组件之间沟通该如何进行（现在<a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#!#parent-to-child" target="_blank" rel="noopener">有了</a>），所以我果断选择了最 Redux 的那种。</p><p>结果发现，后来更新的官方文档里明确说明了不提倡使用这样的方式。</p><p>我只能说很心累……</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>奇葩的路由设定，用 <code>/...</code> 定义一个非最终页面路由，以及没有一个全局的路由结构，让 Angular2 里面的路由变得非常难推导。如果你不一层一层跟踪下去，根本就无法了解整个 Angular2 应用的路由结构。</p><p>莫名其妙的报错，而且很多错误都 Google 不到答案，只能 Google 到一群绝望的开发者提出绝望的问题。看看 Github 上 Angular Repo 里那些绝望的 issue，你就知道后悔当初自己为什么要选 Angular2 作为线上项目的架构了。我自己 Watch 了很多遇到的问题，然而收到最多的更新都是「+1」。</p><p>复杂的生命周期，官方文档看了一遍又一遍，网上的例子搜了很多，又不能确定是不是最新的 API。至今没有全部弄明白 Angular2 所有的生命周期都是干嘛用的，只用过几个简单的 OnInt、AfterViewInit 和 OnChanges。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>写着写着快要变成吐槽 Angular2 了，其实 Angular2 有很多设计的非常不错的地方值得其它框架学习。比如内置的 ViewEncapsulation 解决了 CSS 冲突的问题，完善的 NgForm 系列表单指令能够高效的解决表单校验和提交（前提是那些语法你都学会），底层设计与 DOM 无关以便运行在 WebWorker、服务器等不同环境等等。</p><p>不管怎么样，从项目开始的 Angular2 Alpha，用到现在的 Angular2 Beta 15，学习到了很多新知识，但学到更多的还是自己原来还有这么多不知道。</p><p>后面还是会投入更多的精力在 Redux 生态建设上，毕竟团队内 React + Redux 已经全面开花结果，有必要寻找到 Redux 最优的开发实践。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客停更了近 3 个月，实在是愧对很多在微博上推荐的同学。因为最近大部分时间都投入在公司里一个比较复杂的项目中，直到本周才算正式发布，稍得解脱。&lt;/p&gt;
&lt;p&gt;说这个项目复杂，不仅是因为需求设计复杂，更是因为在这个项目里我们使用了很多新技术 —— Angular2（是的，b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一次使用 git bisect 快速定位 bug 的过程</title>
    <link href="https://undefinedblog.com/git-bisect/"/>
    <id>https://undefinedblog.com/git-bisect/</id>
    <published>2016-01-19T15:43:57.000Z</published>
    <updated>2016-01-19T16:01:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一阵子跟三个同事一起合作开发了基于 Redux 的单页应用，我负责的部分完成的比较早，所有功能测试通过之后代码就没有改动过。</p><p>结果项目上线后不久接到反馈说我开发的某个功能突然用不了了，我自己一试果然不行。但是自己明明已经做过功能测试，甚至用户也试用过，怎么会突然用不了呢？</p><p>因为是一个单页应用，我开始怀疑是别人把我的代码搞坏了。</p><p>于是我尝试 checkout 到一个比较早的 commit，发现一切功能正常，所以肯定是这个 commit 一直到 HEAD 之间的某个（或某几个）commit 把功能搞坏了。</p><p>这个时候我想起了强大的 git bisect 功能。</p><p>不知道为什么，git 的官方文档总是写的让人感觉晦涩难懂，包括 <a href="https://git-scm.com/docs/git-bisect" target="_blank" rel="noopener">bisect 的文档</a>。于是经过一番 Google，我摸索到了核心的使用流程：</p><p>首先，尽可能找到第一个出现问题的 commit，记录其 hash 值；然后，尽可能找到最后一个正常的 commit，记录其 hash 值。</p><p>然后我们就开始了探案过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始 bisect</span></span><br><span class="line">$ git bisect start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 录入正确的 commit</span></span><br><span class="line">$ git bisect good xxxxxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 录入出错的 commit</span></span><br><span class="line">$ git bisect bad xxxxxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后 git 开始在出错的 commit 与正确的 commit 之间开始二分查找，这个过程中你需要不断的验证你的应用是否正常</span></span><br><span class="line">$ git bisect bad</span><br><span class="line">$ git bisect good</span><br><span class="line">$ git bisect good</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直到定位到出错的 commit，退出 bisect</span></span><br><span class="line">$ git bisect reset</span><br></pre></td></tr></table></figure><p>简直是查 bug 小能手！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一阵子跟三个同事一起合作开发了基于 Redux 的单页应用，我负责的部分完成的比较早，所有功能测试通过之后代码就没有改动过。&lt;/p&gt;
&lt;p&gt;结果项目上线后不久接到反馈说我开发的某个功能突然用不了了，我自己一试果然不行。但是自己明明已经做过功能测试，甚至用户也试用过，怎么会
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Lets Encrypt 花三分钟免费接入ssl证书</title>
    <link href="https://undefinedblog.com/lets-encrypt/"/>
    <id>https://undefinedblog.com/lets-encrypt/</id>
    <published>2016-01-02T21:58:24.000Z</published>
    <updated>2016-05-01T11:59:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016-05-01 19:58:46 更新：最近很多朋友说我的 https 证书过期了，于是重新按照 DO 的<a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-14-04" target="_blank" rel="noopener">这篇教程</a>重新配置了一遍。不得不说，DO 写教程的水平确实一流！建议移步学习。</p><hr><p>很久很久以前我还在当个人站长的时候，就一直琢磨着给网站买个 ssl 证书，这样用户访问的时候浏览器上的小绿锁能给人一种非常安全的印象。然而导致我最终没有上 https 的原因有：</p><ol><li>证书好贵 </li><li>https 会影响 SEO（据说） </li><li>懒（<del>这才是真正的原因</del>）</li></ol><p>直到前段时间发现了 <a href="https://letsencrypt.org/" target="_blank" rel="noopener">Lets Encrypt 项目</a>，一个倡导互联网上所有网站都该使用 https 的组织，提供免费的 ssl 证书服务。</p><p><img src="http://ww3.sinaimg.cn/bmiddle/831e9385gw1ezlvzdzwsoj20a70fb75d.jpg" alt="ssl certificate price in godaddy"></p><p>上图是 GoDaddy 的 ssl 证书报价，换句话说，Lets Encrypt 免费送你价值 62.99 刀的证书。</p><p>当然，这里提到价格并不是为了让大家薅羊毛，而是为了体现 Lets Encrypt 组织的高尚目标。希望看到本文的同学，能够享受免费 ssl 证书带来了安全和稳定，而不是产生牟利等不当想法。</p><p>使用的方法也很简单，以 nginx 为例，直接使用 Github 上 xdtianyu 同学提供的<a href="https://github.com/xdtianyu/scripts/tree/master/lets-encrypt" target="_blank" rel="noopener">脚本</a>即可。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>切换到你希望保存证书及私钥的目录，我选择当前用户的 home，即 <code>~</code>。</p><blockquote><p>下文中所有 <code>/path/to/</code> 请替换成你服务器上的实际路径；<code>your_domain</code> 同理替换成你自己的域名</p></blockquote><p>下载脚本及配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget https://raw.githubusercontent.com/xdtianyu/scripts/master/lets-encrypt/letsencrypt.conf</span><br><span class="line">wget https://raw.githubusercontent.com/xdtianyu/scripts/master/lets-encrypt/letsencrypt.sh</span><br><span class="line">chmod +x letsencrypt.sh</span><br></pre></td></tr></table></figure><p>编辑配置文件，将第2、3、4行中的 Example.com 替换成你自己的域名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim letsencrypt.conf</span><br></pre></td></tr></table></figure><p>执行 letsencrypt 脚本，获取证书及私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./letsencrypt.sh ./letsencrypt.conf</span><br></pre></td></tr></table></figure><p>添加 nginx alias</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  location /.well-known/ &#123;</span><br><span class="line">    <span class="built_in">alias</span> /path/to/.well-known/;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 nginx 配置，加载私钥和证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">   listen 443 ssl;</span><br><span class="line">   ssl_certificate /path/to/your_domain.chained.crt;</span><br><span class="line">   ssl_certificate_key /path/to/your_domain.com.key;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>全部操作完成后，重启 nginx 即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service nginx restart</span><br><span class="line"><span class="comment">#或 </span></span><br><span class="line">/etc/init.d/nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="额外配置"><a href="#额外配置" class="headerlink" title="额外配置"></a>额外配置</h2><p>首先，Lets Encrypt 的证书需要每月更新，因此你需要一个 cron 命令定时运行上述脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 * * ~/letsencrypt.sh ~/letsencrypt.conf &gt;&gt; /var/<span class="built_in">log</span>/lets-encrypt.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>其次，如果你希望重定向所有的非 https 到 https 访问，可以在 nginx 配置中添加如下 server block</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name your_domain.com;</span><br><span class="line">    <span class="built_in">return</span> https://your_domain.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，Lets Encrypt 所倡导免费及普遍的 ssl 证书有利于整个互联网环境的安全化。对于某些靠流量劫持广告的 ISP 来说，苦日子要来了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2016-05-01 19:58:46 更新：最近很多朋友说我的 https 证书过期了，于是重新按照 DO 的&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-wit
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redux 在实践中的一些问题及思考</title>
    <link href="https://undefinedblog.com/some-thoughts-in-redux/"/>
    <id>https://undefinedblog.com/some-thoughts-in-redux/</id>
    <published>2015-12-12T19:04:31.000Z</published>
    <updated>2015-12-12T20:35:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>React 绝对是 2015 年前端领域的关键词，基于 React 的 Flux 架构也被越来越多的人所熟识。然而 Flux 作为一套架构思想而不是框架让许多开发者在实践中摸不着头脑，因此社区里也诞生了很多基于 Flux 的「轮子」。而今天要说的就是其中最火、逼格最高的轮子 —— Redux。</p><p>本文不是一篇介绍 Redux 的入门文章（如果大家有兴趣的话，后面可以写写），因此阅读本文至少需要以下几点基础：</p><ol><li><a href="http://facebook.github.io/react/" target="_blank" rel="noopener">React</a>（熟悉）</li><li><a href="http://facebook.github.io/flux/" target="_blank" rel="noopener">Flux</a>（了解）</li><li><a href="https://github.com/rackt/redux" target="_blank" rel="noopener">Redux</a>（了解）</li><li><a href="https://github.com/lukehoban/es6features" target="_blank" rel="noopener">ES 6</a>（了解）</li></ol><p>既然不是基础，那么本文着重要讲的是什么呢？其实是我在实际业务中使用 Redux 遇到的一些问题及我自己的思考。促使我写这篇文章的另一个原因是，知乎上有一位朋友私信咨询了我一些 Redux 相关的问题，让我了解到原来我遇到的问题大家也会有疑惑，因此总结成文，方便后人参考。</p><p>本文将会用类似 cookbook 的形式，通过一问一答来尝试解释 Redux 在实际应用中的问题。</p><h3 id="问题一：一个-action-被-reducer1-处理完之后，希望-reducer2-也对这个-action-做出响应，该怎么处理？"><a href="#问题一：一个-action-被-reducer1-处理完之后，希望-reducer2-也对这个-action-做出响应，该怎么处理？" class="headerlink" title="问题一：一个 action 被 reducer1 处理完之后，希望 reducer2 也对这个 action 做出响应，该怎么处理？"></a>问题一：一个 action 被 reducer1 处理完之后，希望 reducer2 也对这个 action 做出响应，该怎么处理？</h3><p>这个问题其实要从两个方向考虑：即 reducer1 和 reducer2 对某个 action 的响应是否有先后顺序的限制。</p><p>若没有，则在 reducer1 和 reducer2 的 <code>swtich..case..</code> 中针对同一个 <code>ACTION_TYPE</code> 做出处理即可。至于 <code>ACTION_TYPE</code>，则可以在触发这个 action 的 actionCreator.js 里 export 出来。如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actionCreator.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_TYPE = <span class="string">'SOME_ACTION_TYPE'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomeAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: SOME_TYPE,</span><br><span class="line">    payload: <span class="number">123</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer1.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; SOME_TYPE &#125; <span class="keyword">from</span> <span class="string">'./actionCreator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SOME_TYPE: &#123;</span><br><span class="line">      <span class="comment">// 这这个 action 做出响应</span></span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer2.js 同 reducer1.js</span></span><br></pre></td></tr></table></figure><p>若有先后顺序限制，则比较复杂。我们站在整个应用的角度考虑，其实我们的需求是当触发一个 action 时，希望 reducer1 先响应这个 action 更新 state，然后 reducer2 再响应这个 action，也许还需要基于 reducer1 中最新的 store 来更新自己的 state。</p><p>这个时候，可以用我自己写的一个 Redux 中间件 —— <a href="https://github.com/jasonslyvia/redux-sequence-action" target="_blank" rel="noopener">redux-combine-action</a>。使用这种中间件后在 actionCreator 中的逻辑大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actionCreator.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomeAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    (getState, dispatch) =&gt; &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: ACTION_TYPE_1,</span><br><span class="line">        payload: <span class="number">123</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    (getState, dispatch) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> state = getState();</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: ACTION_TYPE_2,</span><br><span class="line">        payload: state.some.useful.data.from.state</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们在 actionCreator 中返回了一个函数数组，每个函数都获得了 getState 和 dispatch 方法。在上述代码中，首先会 dispatch 一个 <code>ACTION_TYPE_1</code> 的 action，假设会被 reducer1 处理，然后会 dispatch 一个 <code>ACTION_TYPE_2</code> 类型的 action，则会被 reducer2 处理。</p><p>对于 reducer 来说，并不关系你的业务逻辑是先处理哪一个后处理哪一个，它们只是单纯的响应每一个 action 而已。</p><p>至于其中的原理，可以自行查看源代码。（写到这的时候，自觉滚去把这个库的测试补上了）需要说明的是，这个中间件的核心思想基本是参考自 <a href="https://github.com/itsmepetrov/redux-combine-actions" target="_blank" rel="noopener">redux-combine-actions</a> 库。</p><h3 id="问题二：Redux-中如何实现一个公共业务组件？"><a href="#问题二：Redux-中如何实现一个公共业务组件？" class="headerlink" title="问题二：Redux 中如何实现一个公共业务组件？"></a>问题二：Redux 中如何实现一个公共业务组件？</h3><p>一个所谓的「公共业务组件」，应该包含了 UI 和数据两部分。比如淘宝上的收货地址选择控件，应该就包含了三个 <code>select</code> 选择器和对应的省市区数据。这样一个地址选择控件的逻辑在各个模块中都是一致的，但是怎么设计才能实现复用呢？</p><blockquote><p>一个关于 Flux/Redux 的基础概念：任何一个 actionCreator 触发的 action 都会通知到所有的 store/reducer。</p></blockquote><p>考虑一种极端情况，页面上同时有两个模块都使用了这个公共的地址选择组件。当在这个组件里选择了一个省份时，会 dispatch 一个 <code>SELECT_PROVINCE</code> 的 action，那么两个模块怎么知道用户到底是选择了哪个模块里公共组件的省份呢？</p><p>再考虑另外一个问题，当用户选择了一个省份后，某一个业务模块希望能够再做一些别的数据处理（比如根据当前选择的省份加载对应的热销宝贝）该怎么操作呢？总不能在 reducer 中 dispatch 一个 action 吧？（<strong>注意，这是 anti-pattern，不要在 reducer 中 dispatch action！！</strong>）</p><p>其实这两个问题的解决思路是类似的，就是在公共组件中，数据传递的过程中加上更多的限制，我能想到的有这么两种解决方案：</p><ul><li>公共组件自己维护状态，业务模块通过给公共组件传入回调来获得公共组件的数据变动，再 dispatch 响应的 action 更新自己的 state。这样设计的问题在于，违背了 Redux 倡导的无状态原则，公共组件内部存在了 state 和 setState 操作。</li><li>通过 props 传入指定的 actionType 或 actionCreator（传入 actionCreator 是我同事奇阳的想法）来让公共组件 dispatch 不同的 action，以此达到区分的效果。</li></ul><p>一个简单的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公共模块自己定义的 actionCreator</span></span><br><span class="line"><span class="keyword">import</span> &#123; provinceActionCreator &#125; <span class="keyword">from</span> <span class="string">'./actionCreator'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个公共的地址选择组件</span></span><br><span class="line"><span class="keyword">const</span> AddressPicker = React.createClass(&#123;</span><br><span class="line">  handleChangeProvince(e) &#123;</span><br><span class="line">    <span class="comment">// 优先使用 props 中传入的 actionCreator</span></span><br><span class="line">    <span class="keyword">const</span> provinceActionCreator = <span class="keyword">this</span>.props.provinceActionCreator || provinceActionCreator;</span><br><span class="line">    <span class="comment">// dispatch 一个选择省份的 action</span></span><br><span class="line">    <span class="keyword">this</span>.props.dispatch(provinceActionCreator(e.target.value));</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;select onChange=&#123;<span class="keyword">this</span>.handleChangeProvince&#125;&gt;</span><br><span class="line">        &lt;option&gt;北京&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">        &lt;option&gt;浙江&lt;/</span>option&gt;</span><br><span class="line">      &lt;<span class="regexp">/select&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></p><h3 id="问题三：Redux-中跟路由有关的状态应该怎么维护？"><a href="#问题三：Redux-中跟路由有关的状态应该怎么维护？" class="headerlink" title="问题三：Redux 中跟路由有关的状态应该怎么维护？"></a>问题三：Redux 中跟路由有关的状态应该怎么维护？</h3><p>现在用 React 做路由的话大家基本都会选择 react-router（这个库我已经吐槽过无数次了，经常改 API），而用 Redux 的话自然也是选择基于 react-router 封装的 redux-router。</p><blockquote><p>在讲详细的问题之前，先要阐明一个观点，即「路由也是应用状态的一部分」，应该也的确有一个单独的 store 在维护它。</p></blockquote><p>既然有一个单独的 store，那么其中的状态就能轻松的获取和设置了，具体的操作方法可以参考 redux-router 中的 API。</p><p>如果抛开 redux-router 不谈，react-router 中针对路由切换时的数据传递提供了一种全新的思路，即在切换路由时，将「state」存入 session-storage 中，借用这个功能你就可以轻松的实现「回退」操作了。</p><p>详细说明见 <a href="https://github.com/rackt/history/blob/master/docs/Glossary.md#locationstate" target="_blank" rel="noopener">history 模块的文档</a>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总的来说，使用 Redux 开发业务功能还是很爽的，尤其是对于数据流动复杂的应用，单一的数据流动、类 Immutable 的数据变动方式以及酷炫的 devtool 这些特性简直堪称神器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React 绝对是 2015 年前端领域的关键词，基于 React 的 Flux 架构也被越来越多的人所熟识。然而 Flux 作为一套架构思想而不是框架让许多开发者在实践中摸不着头脑，因此社区里也诞生了很多基于 Flux 的「轮子」。而今天要说的就是其中最火、逼格最高的轮子
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>setState 之后发生了什么 —— 浅谈 React 中的 Transaction</title>
    <link href="https://undefinedblog.com/what-happened-after-set-state/"/>
    <id>https://undefinedblog.com/what-happened-after-set-state/</id>
    <published>2015-10-25T17:28:22.000Z</published>
    <updated>2015-10-25T17:31:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文系对 <a href="http://undefinedblog.com/understand-react-batch-update/">深入理解 React 的 batchUpdate 机制</a> 的更新，根据 React v0.14 版源码添加并修改了部分内容。同时增加了一张看起来并不容易理解的示意图。</p></blockquote><p>之前在我的博客里有篇文章写了「<a href="http://undefinedblog.com/why-react-is-so-fast/">为什么 React 这么快</a>」，其中说到一点很重要的特性就是 <code>batchUpdate</code>。今天就简单的分析一下 batchUpdate 究竟是怎么实现的？</p><p>首先明确一个基础概念，在调用 this.setState 之后，React 会自动重新调用 render 方法。但是如果我们多次调用 setState 方法呢？考虑下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Example = React.createClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      clicked: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">clicked</span>: <span class="keyword">this</span>.state.clicked + <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">clicked</span>: <span class="keyword">this</span>.state.clicked + <span class="number">1</span>&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;button onClick=&#123;this.handleClick&#125;&gt;&#123;this.state.clicked&#125;&lt;/button&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>考虑这两个问题，当点击 button 时：1、 render 方法被调用了几次？2、 handleClick 中第 2 次 setState 时 this.state.clicked 值是多少？</p><p>如果你还没有把握，可以先打开这个 <a href="http://jsbin.com/zowuve/1/edit?js,console,output" target="_blank" rel="noopener">DEMO</a> 查看结果。</p><p>知道结果后，你能解释为什么 render 方法只被调用了 1 次，且第二次 setState 时 this.state.clicked 依然是 0 么？</p><p>这一切，都要归功于 React 的 batchUpdate 设计，但是 batchUpdate 究竟是怎么实现的呢？让我们深入到 React 的源码中一探究竟。</p><blockquote><p>以下内容由于本人能力及精力均有限，尚未深究，仅供参考。如有错误，尽请斧正！源码分析基于 React v0.14 版。</p></blockquote><p>一个简单的 setState 方法，其简化的调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">this.setState                                           // ReactComponent.js</span><br><span class="line">...</span><br><span class="line">this.updater.enqueueSetState                            // ReactUpdateQueue.js</span><br><span class="line">...</span><br><span class="line">获取当前组件的 pendingStateQueue，并将新的 state push 进去 // ReactUpdateQueue.js</span><br><span class="line">...</span><br><span class="line">enqueueUpdate                                           // ReactUpdates.js</span><br><span class="line">...</span><br><span class="line">if(当前不在一次 batchUpdate 的过程中)                      // ReactUpates.js</span><br><span class="line">  执行 batchingStreategy.batchUpdates 方法</span><br><span class="line">else</span><br><span class="line">  将当前 component 存入 dirtyComponents 数组中</span><br><span class="line">...</span><br><span class="line">if (setState 方法存在 callback)                          // ReactComponent.js</span><br><span class="line">  调用 this.updater.enqueueCallback 将 callback 存入队列中</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一次 setState 的过程大概就是这样，那么问题来了，setState 只是把变化存入一个临时队列中，那么新的 state 究竟是如何生效的呢？</p><p>让我们从 DOM 事件触发开发对整个链路进行一下梳理：</p><p>当一次 DOM 事件触发后，ReactEventListener.dispatchEvent 方法会被调用。而这个方法并不是急着去调用我们在 JSX 中指定的各种回调，而是调用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactUpdates.batchedUpdates</span><br></pre></td></tr></table></figure><p>该方法会执行一个 transaction，而要执行的内容被定义在 handleTopLevelImpl 中。再看 handleTopLevelImpl，其核心内容就是找到事件对应的所有节点并依次对这些节点 trigger 事件。</p><p>在进一步介绍之前，我们需要先了解一下 Transaction（事务）。</p><p>React 为 Transaction 封装了一个简单的 Mixin，并在源码中生动的介绍了一个 Transaction 是怎么工作的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 详见 Transaction.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *                       wrappers (injected at creation time)</span></span><br><span class="line"><span class="comment"> *                                      +        +</span></span><br><span class="line"><span class="comment"> *                                      |        |</span></span><br><span class="line"><span class="comment"> *                    +-------------------------------------+</span></span><br><span class="line"><span class="comment"> *                    |                 v        |              |</span></span><br><span class="line"><span class="comment"> *                    |      +---------------+   |              |</span></span><br><span class="line"><span class="comment"> *                    |   +--|    wrapper1   -----+         |</span></span><br><span class="line"><span class="comment"> *                    |   |  +---------------+   v    |         |</span></span><br><span class="line"><span class="comment"> *                    |   |          +-------------+  |         |</span></span><br><span class="line"><span class="comment"> *                    |   |     +----|   wrapper2  -------+   |</span></span><br><span class="line"><span class="comment"> *                    |   |     |    +-------------+  |     |   |</span></span><br><span class="line"><span class="comment"> *                    |   |     |                     |     |   |</span></span><br><span class="line"><span class="comment"> *                    |   v     v                     v     v   | wrapper</span></span><br><span class="line"><span class="comment"> *                    | +---+ +---+   +---------+   +---+ +---+ | invariants</span></span><br><span class="line"><span class="comment"> * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained</span></span><br><span class="line"><span class="comment"> * +-----------------&gt;-----&gt;|anyMethod-------------&gt;</span></span><br><span class="line"><span class="comment"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="comment"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="comment"> *                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="comment"> *                    | +---+ +---+   +---------+   +---+ +---+ |</span></span><br><span class="line"><span class="comment"> *                    |  initialize                    close    |</span></span><br><span class="line"><span class="comment"> *                    +-----------------------------------------+</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure><p>实际上，Transacation 就是给需要执行的函数封装了两个 wrapper，每个 wrapper 都有 initialize 和 close 方法。当一个 transaction 需要执行（perform）的时候，会先调用对应的 initialize 方法。同样的，当一个 transaction 执行完成后，会调用对应的 close 方法。</p><p>回到刚才的问题，存入临时队列的 state 究竟是怎么被改变成真正的状态的呢？秘密就在 <code>ReactUpdates.batchedUpdates</code> 调用中（还记得它吗？DOM 事件的回调中被调用的方法）。这个方法实际上就是执行了一个 transaction，具体实现定义在 ReactDefaultBatchingStrategy.js 中。</p><p>这个 transaction 具体的代码就不贴了，简单的说，它定义了一个事务，当这个事务结束时，需要调用 ReactUpdates.flushBatchedUpdates 方法。</p><p>好，说到这里可能大家已经被各种名称搞昏了头，下面给大家看一个简单的流程图。</p><p><img src="http://ww1.sinaimg.cn/large/831e9385gw1exdvqnke7nj21be0fwtc9.jpg" alt="react transaction 图例"></p><p>上面的流程图中只保留了部分核心的过程，看到这里大家应该明白了，所有的 batchUpdate 功能都是通过执行各种 transaction 实现的。this.setState 调用后，新的 state 并没有马上生效，而是通过 ReactUpdates.batchedUpdate 方法存入临时队列中。当一个 transaction 完成后，才通过 ReactUpdates.flushBatchedUpdates 方法将所有的临时 state merge 并计算出最新的 props 及 state。</p><p>纵观 React 源码，使用 Transaction 之处非常之多，React 源码注释中也列举了很多可以使用 Transaction 的地方，比如</p><ul><li>在一次 DOM reconciliation（调和，即 state 改变导致 Virtual DOM 改变，计算真实 DOM 该如何改变的过程）的前后，保证 input 中选中的文字范围（range）不发生变化</li><li>当 DOM 节点发生重新排列时禁用事件，以确保不会触发多余的 blur/focus 事件。同时可以确保 DOM 重拍完成后事件系统恢复启用状态。</li><li>当 worker thread 的 DOM reconciliation 计算完成后，由 main thread 来更新整个 UI</li><li>在渲染完新的内容后调用所有 <code>componentDidUpdate</code> 的回调</li><li>等等</li></ul><p>值得一提的是，React 还将 batchUpdate 方法暴露了出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> batchedUpdates = <span class="built_in">require</span>(<span class="string">'react-dom'</span>).unstable_batchedUpdates;</span><br></pre></td></tr></table></figure><p>当你需要在一些非 DOM 事件回调的函数中多次调用 setState 等方法时，可以将你的逻辑封装后调用 batchedUpdates 执行，以此保证 render 方法不会被多次调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文系对 &lt;a href=&quot;http://undefinedblog.com/understand-react-batch-update/&quot;&gt;深入理解 React 的 batchUpdate 机制&lt;/a&gt; 的更新，根据 React v0.14 版源
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React v0.14 概览</title>
    <link href="https://undefinedblog.com/react-v0-14/"/>
    <id>https://undefinedblog.com/react-v0-14/</id>
    <published>2015-10-07T18:21:24.000Z</published>
    <updated>2015-10-07T19:27:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本上本文就是对 <a href="http://facebook.github.io/react/blog/2015/10/07/react-v0.14.html" target="_blank" rel="noopener">React 官方 v0.14 博文</a> 的翻译加上一小部分个人理解。</p></blockquote><p>正文开始之前先讲个笑话，随着 React 的风靡许多基于 React 的衍生库也火得一塌糊涂，比如 <a href="https://github.com/rackt/react-router" target="_blank" rel="noopener">React Router</a>。如果没记错的话 React Router 的作者说过版本号永远和 React 保持一致，从 v0.10 开始确实如此。然后 v0.11，v0.12，v0.13，眼看着时间已经过去了一年多……怎么着也该出 v1.0 了吧，结果 React 发布了 v0.14，而且还规划了 v0.15，让 React Router 的若干个 v1.0-beta 版本哭瞎在厕所。</p><p><img src="http://ww3.sinaimg.cn/bmiddle/831e9385gw1ewt4ti4nevj20c50kqq4s.jpg" alt="react router github repo"></p><p>好了，回到 React v0.14 上。</p><h3 id="React-「一分为二」"><a href="#React-「一分为二」" class="headerlink" title="React 「一分为二」"></a>React 「一分为二」</h3><p>原本的 <code>react</code> package 被拆分为 <code>react</code> 及 <code>react-dom</code> 两个 package。其中 <code>react</code> package 中包含 <code>React.createElement</code>、 <code>.createClass</code>、 <code>.Component</code>， <code>.PropTypes</code>， <code>.Children</code> 这些 API，而 <code>react-dom</code> package 中包含 <code>ReactDOM.render</code>、 <code>.unmountComponentAtNode</code>、 <code>.findDOMNode</code>。</p><p>原本在服务端渲染用的两个 API <code>.renderToString</code> 和 <code>.renderToStaticMarkup</code> 被放在了 <code>react-dom/server</code> 中。</p><p>改变之后的结构，一个基本的 React 组件变成了这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"><span class="keyword">var</span> ReactDOM = <span class="built_in">require</span>(<span class="string">'react-dom'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MyComponent = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;Hello World&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;MyComponent /&gt;, node);</span><br></pre></td></tr></table></figure><p>此外，原本 <code>React.addons</code> 下面的工具全部变成了独立的 package：</p><ul><li>react-addons-clone-with-props</li><li>react-addons-create-fragment</li><li>react-addons-css-transition-group</li><li>react-addons-linked-state-mixin</li><li>react-addons-perf</li><li>react-addons-pure-render-mixin</li><li>react-addons-shallow-compare</li><li>react-addons-test-utils</li><li>react-addons-transition-group</li><li>react-addons-update</li><li>ReactDOM.unstable_batchedUpdates （在 <code>react-dom</code> 中）</li></ul><p>当然，原本的 API 在 v0.14 版中仍然可以使用，只不过会有 warning，最终会在 v0.15 版的时候完全移除。</p><h3 id="refs-变成了真正的-DOM-节点"><a href="#refs-变成了真正的-DOM-节点" class="headerlink" title="refs 变成了真正的 DOM 节点"></a>refs 变成了真正的 DOM 节点</h3><p>当我们需要获取 React 组件上某个 DOM 节点时，React 提供了 refs 方法方便我们快速引用。为了方便我们使用，React 还「贴心」地对 refs 做了一层封装，使用 <code>this.refs.xxx.getDOMNode()</code> 或 <code>React.findDOMNode(this.refs.xxx)</code> 可以获取到真正的 DOM 节点。</p><p>结果发现大家真正需要的就是 DOM 节点本身，封装了半天完全是浪费感情。</p><p>于是在 v0.14 版中 refs 指向的就是 DOM 节点，同时也会保留 <code>.getDOMNode()</code> 方法（带 warning），最终在 v0.15 版中去除该方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Zoo = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;Giraffe name: &lt;input ref="giraffe" /&gt;&lt;/div&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line">  showName: function() &#123;</span><br><span class="line">    // 之前：</span><br><span class="line">    // var input = this.refs.giraffe.getDOMNode();</span><br><span class="line">    //</span><br><span class="line">    // v0.14 版：</span><br><span class="line">    var input = this.refs.giraffe;</span><br><span class="line">    alert(input.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要注意的是，如果你给自定义的 React 组件（除了 DOM 自带的标签，如 <code>div</code>、<code>p</code> 等）添加 refs，表现和行为与之前一致。</p><h3 id="无状态的函数式组件"><a href="#无状态的函数式组件" class="headerlink" title="无状态的函数式组件"></a>无状态的函数式组件</h3><p>其实在实际业务系统中使用 React 时，我们会写很多只有 <code>render</code> 方法的 React 组件。为了减少冗余的代码量，React v0.14 中引入了 <code>无状态的函数式组件（Stateless functional components）</code> 的概念。先看看长啥样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个 ES6 箭头函数定义的无状态函数式组件</span></span><br><span class="line"><span class="keyword">var</span> Aquarium = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> fish = getFish(props.species);</span><br><span class="line">  <span class="keyword">return</span> &lt;Tank&gt;&#123;fish&#125;&lt;/Tank&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者更加简化的版本</span></span><br><span class="line"><span class="keyword">var</span> Aquarium = <span class="function">(<span class="params">&#123;species&#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;Tank&gt;</span><br><span class="line">    &#123;getFish(species)&#125;</span><br><span class="line">  &lt;<span class="regexp">/Tank&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 最终使用方式: &lt;Aquarium species="rainbowfish" /</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看到，没有 <code>React.createClass</code>，也没有显式的 <code>render</code>，写起来更加轻松了。</p><p>当然，新语法也有需要注意的地方：</p><ol><li>没有任何生命周期方法，如 <code>componentDidMount</code> 等</li><li>不能添加 refs</li><li>可以通过给函数添加属性定义 <code>propTypes</code> 和 <code>defaultProps</code></li></ol><h3 id="react-tools-及-JSXTransformer-js-已弃用"><a href="#react-tools-及-JSXTransformer-js-已弃用" class="headerlink" title="react-tools 及 JSXTransformer.js 已弃用"></a>react-tools 及 JSXTransformer.js 已弃用</h3><p>拥抱 Babel 吧同学们！</p><h3 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h3><p>在 Babel 5.8.23 及更新的版本中，新增了两项专门针对 React 的优化配置，<strong>仅推荐在生产环境中开启</strong>，因为优化后会导致代码的报错更加扑朔迷离（本来报错就已经很难定位了……）。</p><ul><li><code>optimisation.react.inlineElements</code> 将 JSX 元素转换为对象而非使用 <code>React.createElement</code></li><li><code>optimisation.react.constantElements</code> 针对拥有完全静态子树的组件，将其创建过程提升到顶层（Top level），从而减少对 <code>React.createElement</code> 方法的调用</li></ul><h3 id="其它变化"><a href="#其它变化" class="headerlink" title="其它变化"></a>其它变化</h3><ul><li><code>React.initializeTouchEvents</code> 已弃用</li><li>由于 refs 的相关变化（见上文），<code>TestUtils.findAllInRenderedTree</code> 及相关的方法不再接受 DOM 组件作为参数，只能传入自定义的 React 组件</li><li><code>props</code> 一旦创建永远不可修改，因此 <code>.setProps</code> 及 <code>.replaceProps</code> 已废弃</li><li><code>children</code> 不可以传对象类型，推荐传入数组，或使用 <code>React.createFragment</code> 方法（其实就是转换为了数组）</li><li><code>React.addons.classSet</code> 已经移除，使用 <code>classnames</code> package 替代</li></ul><h3 id="将要发生的改变"><a href="#将要发生的改变" class="headerlink" title="将要发生的改变"></a>将要发生的改变</h3><p>在 v0.15 版中，下列内容将会发生改变：</p><ul><li><code>this.getDOMNode()</code> 方法将会废弃，推荐使用 <code>React.findDOMNode()</code></li><li><code>setProps</code> 及 <code>replaceProps</code> 将会废弃</li><li><code>React.addons.cloneWithProps</code> 已废弃，推荐使用 <code>React.cloneElements</code>，新方法不会自动 merge <code>className</code> 及 <code>style</code></li><li><code>React.addons.CSSTransitionGroup</code> 将不再监听 transition 事件，因此使用者需要显式指定动画的 timeout，如：<code>transitionEnterTimeout={500}</code>。</li><li>ES6 组件类必须 extends React.Component（如果使用 React.createClass 语法则不受影响）</li><li>在多次 render 中重用并改变 style 对象已经被弃用（这一点不是太明白，中心思想貌似是不要 mutate object？）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基本上本文就是对 &lt;a href=&quot;http://facebook.github.io/react/blog/2015/10/07/react-v0.14.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React 官方 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>再谈 React Router 使用方法</title>
    <link href="https://undefinedblog.com/react-router-0-13-3/"/>
    <id>https://undefinedblog.com/react-router-0-13-3/</id>
    <published>2015-08-18T13:17:10.000Z</published>
    <updated>2015-08-18T16:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年 9 月份写了一篇 <a href="http://undefinedblog.com/react-router/">ReactRouter 使用指南</a>，不小心在百度搜索「react-router」关键词排到了第一名。最近收到很多同学反馈说这篇文章里的例子挂了让我补一下。</p><p>其实例子里的代码已经很老了，React Router 的 API 也发生了很多变化。因此今天抽出一晚上的时间，再以最新的 React Router 稳定版（截止 2015年08月18日21:23:40 为 v0.13.3 版，与 React 版本号一致）为基础讲讲如何使用 React Router。</p><blockquote><p>阅读本文需要你有一定的 ReactJS 基础，如果你正在寻找 ReactJS 中文入门教程，推荐我参与翻译的 <a href="http://book.douban.com/subject/26378583/" target="_blank" rel="noopener">React - 引领未来的用户界面开发框架</a> 一书。</p></blockquote><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>一个最基本的页面，菜单有「图书」和「电影」两个菜单项，点击「图书」显示图书列表（链接变为/books），点击「电影」显示电影列表（链接变为/movies）。</p><p><a href="http://jsbin.com/duduta/14/edit?js,output" target="_blank" rel="noopener">Demo</a></p><p>说实话，这个例子并不简单。下面逐步分析一下用到的代码和它们分别是干什么的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Router = ReactRouter; <span class="comment">// 由于是html直接引用的库，所以 ReactRouter 是以全局变量的形式挂在 window 上</span></span><br><span class="line"><span class="keyword">var</span> Route = ReactRouter.Route; </span><br><span class="line"><span class="keyword">var</span> RouteHandler = ReactRouter.RouteHandler;</span><br><span class="line"><span class="keyword">var</span> Link = ReactRouter.Link;</span><br><span class="line"><span class="keyword">var</span> StateMixin = ReactRouter.State;</span><br></pre></td></tr></table></figure><p>由于 Demo 需要直接从网页上引用 React 和 React Router，因此它们都被挂在了 window 对象上（现在但凡有点追求的前端都上 webpack 了，但是例子的话大家就将就着看吧）。这几行就是获取 ReactRouter 提供的几个组件和 mixin。</p><p>接下来声明了 4 个组件，都是最基本的只有 render 方法的 React 组件，分别是：<code>Movies 电影列表</code>、<code>Movie 电影详情</code>、<code>Books 图书列表</code>、<code>Book 图书详情</code>。</p><p>关于组件唯一需要说明的是用到了 ReactRouter 提供的 <code>State</code> 这个 mixin，主要功能就是让组件能够通过 this.getParams() 或 this.getQuery() 等方法获取到当前路由的各种值或参数。</p><p>然后是应用的入口，也是我们渲染菜单的地方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用入口</span></span><br><span class="line"><span class="keyword">var</span> App = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;nav&gt;</span><br><span class="line">          &lt;Link to=<span class="string">"movies"</span>&gt;电影&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Link to="books"&gt;图书&lt;/</span>Link&gt;</span><br><span class="line">        &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">        &lt;section&gt;</span></span><br><span class="line"><span class="regexp">          &lt;RouteHandler /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里用到了两个 ReactRouter 提供的组件：<code>Link</code> 和 <code>RouteHandler</code>。</p><p>Link 组件可以认为是 ReactRouter 提供的对 <code>&lt;a&gt;</code> 标签进行封装的组件，你可以查看 Link 组件渲染到 DOM 上其实就是 a 标签。它接受的 props 有 to、params 和 query。to 可以是一个路由的名称（下文会讲到），也可以是一个完整的 http 地址（类似 href 属性）；params 和 query 都是这个链接带的参数，下文细讲。</p><p>此外，Link 组件还有一个小特点，就是如果这个 Link 组件指向的路由被激活的话，组件会自动添加一个值为 <code>active</code> 的 className，方便你对当前激活的菜单项设置不同的样式（注意 demo 中红色的菜单项）。</p><p>而 RouteHandler 组件是 ReactRouter 的核心组件之一，它代表着当前路由匹配到的 React 组件。假设当前的路由为 <code>/books</code>，那么 App 这个组件里的 RouteHandler 其实就是 Books 组件。</p><p>那么这个关系是怎么得来的呢？就要看下面定义的页面路由了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义页面上的路由</span></span><br><span class="line"><span class="keyword">var</span> routes = (</span><br><span class="line">  &lt;Route handler=&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"movies"</span> handler=&#123;Movies&#125; /&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"movie"</span> path=<span class="string">"/movie/:id"</span> handler=&#123;Movie&#125; /&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"books"</span> handler=&#123;Books&#125; /&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"book"</span> path=<span class="string">"/book/:id"</span> handler=&#123;Book&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>这里又出现了另外一个 ReactRouter 提供的组件 <code>Route</code>，这个组件就是定义整个页面路由的基础，可以嵌套。</p><p>Route 接受的 props 包括 name、path、handler 等等。其中 name 就是上文提到的路由名称，可以通过 <code>&lt;Link to=&quot;路由的名称&quot;&gt;</code> 来生成一个跳转到该路由的链接。path 指明的是当前路由对应的 url，如果不指定，那么默认就是 <code>name</code> 对应的值；如果 <code>name</code> 也不指定，那默认是 <code>/</code>，即根目录。另外 path 还支持指定 params（上文有提到），就是上面的例子中 <code>:</code> 及后面跟着的名称。</p><blockquote><p>params 和 query 的区别在于，params 定义的是「路由」中的参数，比如 /movies/:id ，params 为 id；而 query 是 「URL」中的参数，是跟在 URL 中「?」后面的。定义路由时一般不考虑也不能限制 query 会是什么。</p></blockquote><p>比如 <code>&lt;Route name=&quot;movies&quot; handler={Movie} /&gt;</code> 就指明了一条指向 <code>/movies</code> 的路由，当该路由激活时，调用 <code>Movies</code> 这个组件进行渲染。</p><p>接下来就是最后一步，根据上面定义的路由判断出当前该渲染哪个组件，并将其渲染到 DOM 中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将匹配的路由渲染到 DOM 中</span></span><br><span class="line">Router.run(routes, Router.HashLocation, <span class="function"><span class="keyword">function</span>(<span class="params">Root</span>)</span>&#123;</span><br><span class="line">  React.render(&lt;Root /&gt;, document.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Router 即 ReactRouter，run 方法接受 2 - 3个参数，其中第一个参数必填，即我们指定的路由规则。第二个参数选填，即路由的实现方式，<code>Router.HashLocation</code> 指明了当前页面使用 hash 变化来实现路由，反映在浏览器的地址栏中就是类似 <code>xxx.com/#/movies</code> 这样的地址。使用这种 Location 的好处是兼容 IE 8，如果你的应用不需要兼容 IE 8，可以使用更高级的 <code>Router.HistoryLocation</code>。</p><p>最后一个参数是一个回调函数，函数的第一个参数是 ReactRouter 判断出的当前路由中需要渲染的根节点组件，在这里就是 <code>&lt;App /&gt;</code> 这个组件（虽然名字叫做 Root，但在本例中 Root 指的就是 App）。</p><p>最后的最后，就是熟悉的 React API，将 Root 渲染到 DOM 中，看到的结果如下：</p><p><img src="http://ww2.sinaimg.cn/bmiddle/831e9385gw1ev76w5qp08j205b01iwea.jpg" alt="react router demo"></p><p>尝试点击一下各种链接看看效果吧！</p><p><a href="http://jsbin.com/duduta/14/edit?js,output" target="_blank" rel="noopener">Demo</a></p><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>上面贴了这么多代码分析了这么一大段，只实现了一个非常基础的 ReactRouter 路由例子。你在把玩这个例子的时候应该会发现，页面默认打开的时候（即路由为 <code>/</code> 的时候），除了菜单什么也没有显示，显得比较单调。</p><p>这个时候你有两种选择：使用 <code>DefaultRoute</code> 或 <code>Redirect</code>。</p><p>如果我们希望页面默认进来的时候除了菜单之外再显示一个类似首页的组件，那么可以用 ReactRouter 提供的 <code>DefaultRoute</code>。</p><p><a href="http://jsbin.com/duduta/15/edit?js,output" target="_blank" rel="noopener">Demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义页面上的路由</span></span><br><span class="line"><span class="keyword">var</span> routes = (</span><br><span class="line">  &lt;Route handler=&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"movies"</span> handler=&#123;Movies&#125; /&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"movie"</span> path=<span class="string">"/movie/:id"</span> handler=&#123;Movie&#125; /&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"books"</span> handler=&#123;Books&#125; /&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"book"</span> path=<span class="string">"/book/:id"</span> handler=&#123;Book&#125; /&gt;</span><br><span class="line">    &lt;DefaultRoute handler=&#123;Index&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>注意 routes 中定义的路由，多了一个 DefaultRoute，它的 handler 是 Index 组件，即我们希望用户在默认打开页面时看到的组件内容。</p><p>如果你不想这么麻烦，想用户进来默认就看到电影列表，则可以使用 Redirect 组件。</p><p><a href="http://jsbin.com/duduta/18/edit?js" target="_blank" rel="noopener">Demo</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义页面上的路由</span></span><br><span class="line"><span class="keyword">var</span> routes = (</span><br><span class="line">  &lt;Route handler=&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"movies"</span> handler=&#123;Movies&#125; /&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"movie"</span> path=<span class="string">"/movie/:id"</span> handler=&#123;Movie&#125; /&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"books"</span> handler=&#123;Books&#125; /&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"book"</span> path=<span class="string">"/book/:id"</span> handler=&#123;Book&#125; /&gt;</span><br><span class="line">    &lt;Redirect to=<span class="string">"movies"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>可以看到，当我们直接访问这个 URL 的时候，自动被重定向到了 <code>/movies</code>。Redirect 同时接受 from 这个 props，可以指定当什么规则下才进行重定向。</p><h2 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h2><p>配合 DefaultRoute 和 Redirect，我们的路由已经基本成型了，但是目前还遇到一个问题：在显示电影详情或图书详情时，对应的菜单项没有高亮。</p><p><img src="http://ww4.sinaimg.cn/bmiddle/831e9385gw1ev76wlk6anj205r049wei.jpg" alt="react-router-demo"></p><p><img src="http://ww2.sinaimg.cn/bmiddle/831e9385gw1ev76wtyoqoj208c03cmx3.jpg" alt="react-router-demo"></p><p>这是为什么呢？上文说到了 Link 组件会在指向的路由被激活时自动添加值为 「active」 的 className。而我们的两个 Link 分别指向的是 <code>/movies</code> 和 <code>/books</code>。而详情页的 URL 是 <code>/movie/1</code> 或 <code>/book/1</code> 这种形式，显然不满足 Link 被激活的条件。</p><p>这个时候又有两个方案可以选择了……「嵌套路由」或是「动态判断」。</p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>让我们对路由进行一些改造：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义页面上的路由</span></span><br><span class="line"><span class="keyword">var</span> routes = (</span><br><span class="line">  &lt;Route handler=&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"movies"</span> handler=&#123;Movies&#125;&gt;</span><br><span class="line">      &lt;Route name=<span class="string">"movie"</span> path=<span class="string">":id"</span> handler=&#123;Movie&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Route name="books" handler=&#123;Books&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Route name="book" path=":id" handler=&#123;Book&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Route&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>同时改造一下图书列表和电影列表组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书列表组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Books = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li key=&#123;<span class="number">1</span>&#125;&gt;&lt;Link to="book" params=&#123;&#123;id: 1&#125;&#125;&gt;活着&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">          &lt;li key=&#123;<span class="number">2</span>&#125;&gt;&lt;Link to="book" params=&#123;&#123;id: 2&#125;&#125;&gt;挪威的森林&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">          &lt;li key=&#123;<span class="number">3</span>&#125;&gt;&lt;Link to="book" params=&#123;&#123;id: 3&#125;&#125;&gt;从你的全世界走过&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;RouteHandler /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><p>注意到首先我们的路由变成了嵌套模式，原本电影列表和电影详情的路由是平级的，一个指向 <code>/movies</code>，一个指向 <code>/movie/:id</code>。改造之后，路由形成了嵌套关系，电影列表的路由依然是 <code>/movies</code>，而电影详情变成了 <code>/movies/:id</code>。</p><p><a href="http://jsbin.com/duduta/20/edit?js" target="_blank" rel="noopener">Demo</a></p><p>经过改造之后显示详情的时候菜单可以正确的高亮了，然而列表内容也被显示了出来，很多时候我们并不需要列表和详情同时出现，这个时候就需要另一种路由处理方式：动态判断。</p><blockquote><p>其实我们的路由从最开始就存在嵌套模式，记得最外层 handler 是 App 的 Route 吗？里面所有的路由都是被嵌套的。</p></blockquote><h3 id="动态判断"><a href="#动态判断" class="headerlink" title="动态判断"></a>动态判断</h3><p>让我们再次对路由进行改造：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义页面上的路由</span></span><br><span class="line"><span class="keyword">var</span> routes = (</span><br><span class="line">  &lt;Route handler=&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"movies"</span> path=<span class="string">"/movies/:id?"</span> handler=&#123;Movies&#125; /&gt;</span><br><span class="line">    &lt;Route name=<span class="string">"books"</span> path=<span class="string">"/books/:id?"</span> handler=&#123;Books&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>取消了嵌套在列表路由下的详情页路由，同时改造了列表页路由的 path，从原来的 <code>/movies</code> 改为 <code>/movies/:id?</code>。这样的 path 代表着这条路由匹配所有 <code>/movies/</code> 开头的 URL，同时可能存在一个 id 参数，也可能不存在。</p><p>看起来路由变简单了不少，不过对应的代价是组件中的代码需要大改。</p><p>主要的变动包括：</p><p>列表组件中渲染增加逻辑动态判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 图书列表组件</span><br><span class="line"> */</span><br><span class="line">var Books = React.createClass(&#123;</span><br><span class="line">  mixins: [StateMixin],</span><br><span class="line">  </span><br><span class="line">  render: function() &#123;</span><br><span class="line">    </span><br><span class="line">    var id = this.getParams().id;</span><br><span class="line">    return id ? &lt;Book id=&#123;id&#125; /&gt; : (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li key=&#123;1&#125;&gt;&lt;Link to=&quot;books&quot; params=&#123;&#123;id: 1&#125;&#125;&gt;活着&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">          &lt;li key=&#123;2&#125;&gt;&lt;Link to=&quot;books&quot; params=&#123;&#123;id: 2&#125;&#125;&gt;挪威的森林&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">          &lt;li key=&#123;3&#125;&gt;&lt;Link to=&quot;books&quot; params=&#123;&#123;id: 3&#125;&#125;&gt;从你的全世界走过&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;RouteHandler /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>详情页组件不再从路由中获取数据，而是根据父组件提供的 props 进行渲染：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单本图书组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Book = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;article&gt;</span><br><span class="line">       &lt;h1&gt;这里是图书 id 为 &#123;<span class="keyword">this</span>.props.id&#125; 的详情介绍&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>article&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="http://jsbin.com/duduta/24/edit?js" target="_blank" rel="noopener">Demo</a></p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>ReactRouter 还提供了 <code>willTransitionTo</code> 和 <code>willTransitionFrom</code> 两个静态方法，用于某个组件将要被激活和某个组件将要被取消激活时进行拦截或进行相关操作。</p><p>由于这两个 API 很可能在 1.0 正式版中被砍掉，这里就不多做介绍了。</p><h2 id="ReactRouter-小结"><a href="#ReactRouter-小结" class="headerlink" title="ReactRouter 小结"></a>ReactRouter 小结</h2><p>花了一个晚上的时间把自己一年前挖下的坑松了松土，看到这里你以为自己已经学会 ReactRouter 怎么用了吗？呵呵，偷偷告诉你，ReactRouter 1.0 的 API 变化挺大的（目前已有 1.0 beta3 版）。这个库非常激进，维护的非常频繁，带来的后果就是 API 变动也很频繁。</p><p>不管怎么样，拥抱变化吧！</p><p><a href="http://rackt.github.io/react-router/" target="_blank" rel="noopener">React Router 官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;去年 9 月份写了一篇 &lt;a href=&quot;http://undefinedblog.com/react-router/&quot;&gt;ReactRouter 使用指南&lt;/a&gt;，不小心在百度搜索「react-router」关键词排到了第一名。最近收到很多同学反馈说这篇文章里的例子挂了让我
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最近踩得两个 IE 深坑</title>
    <link href="https://undefinedblog.com/recent-ie-quirks/"/>
    <id>https://undefinedblog.com/recent-ie-quirks/</id>
    <published>2015-08-12T14:49:17.000Z</published>
    <updated>2015-08-12T15:05:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果这个世界上没有 IE，前端程序员的寿命至少延长十年。作为一个有节操的程序员，对于 IE 下的各种 quirks 就算不说了如指掌也应该略有了解。什么 IE 6 下 margin 双边距啦、IE 的 Object.defineProperty 只支持 DOM 节点啦，都是小意思！最近踩了两个不太常见的 IE 坑，记录下来跟大家分享，也希望后人能避免再次踩坑。</p><h2 id="IE-9-的样式表限制"><a href="#IE-9-的样式表限制" class="headerlink" title="IE 9 的样式表限制"></a>IE 9 的样式表限制</h2><p>IE 对 CSS 选择器的支持非常有限，按理说 IE 9 应该基本算是一个可以用的浏览器了，然而，它对于样式表也有变态的限制。具体限制规则如下：</p><ul><li>一个样式表（.css 文件）最多只能包含 4,095 个选择器</li><li>一个样式表最多只能 <code>@import</code> 31 个样式表</li><li><code>@import</code> 指令最多只能嵌套 4 层</li></ul><p>其中我就结结实实的踩中了第一个坑，因为我们的应用非常复杂，所以单独抽出了一个基础库，包含了多个页面公用的 js 和 css，谁曾想公共的 css 文件选择器数量不知不觉已经达到了 4,300 多个。这样直接导致的后果就是部分选择器及样式被 IE 9 无情的抛弃了。</p><p>解决方案：不要触犯以上规则，拆分样式表，去除不必要的选择器</p><p>解决工具：<a href="https://github.com/jasonslyvia/gulp-legacy-ie-css-lint" target="_blank" rel="noopener">gulp-legacy-ie-css-lint</a></p><p>来源参考：<a href="http://stackoverflow.com/questions/9906794/internet-explorers-css-rules-limits" target="_blank" rel="noopener">so</a></p><h2 id="IE-8-下-resize-事件的频繁触发"><a href="#IE-8-下-resize-事件的频繁触发" class="headerlink" title="IE 8 下 resize 事件的频繁触发"></a>IE 8 下 resize 事件的频繁触发</h2><p>最近因为业务需要写了一个 <a href="">react-lazyload</a> 组件（非常好用喔，已经在阿里的对外业务上全面铺开使用了），但是在 IE 8 下性能巨差。经过艰难的断点调试发现，lazyload 的回调被调用的太过频繁了（即使已经加了 300ms 的 debounce）。经过一番 Google 后发现，IE 8 处理 resize 事件的方式简直是变态。</p><p>根据 MDN 的描述：</p><blockquote><p>The resize event is fired when the document view has been resized.</p></blockquote><p>resize 事件应该是当文档可视区域发生变化时触发的（即当你放大或缩小浏览器窗口时），而 IE 8 下却不是。IE 8 下触发 resize 事件的逻辑是：</p><p>当<strong>一个元素的尺寸</strong>发生改变的时候，就触发 resize 事件</p><p>这样当你更新 DOM 节点的时候，resize 事件的触发频率及次数可想而知。</p><p>解决方案：不需要使用 resize 事件的时候尽量不要绑定这个事件；实在需要的话在 DOM 可能发生改变前解除 resize 事件的绑定，在 DOM 更新完成后重新监听 resize 事件</p><p>来源参考：<a href="http://stackoverflow.com/questions/1852751/window-resize-event-firing-in-internet-explorer" target="_blank" rel="noopener">so</a></p><p>这里多说一句，很多应用在 IE 8 下觉得卡顿，也可以检查一下是否因为绑定了 resize 事件的缘故。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果这个世界上没有 IE，前端程序员的寿命至少延长十年。作为一个有节操的程序员，对于 IE 下的各种 quirks 就算不说了如指掌也应该略有了解。什么 IE 6 下 margin 双边距啦、IE 的 Object.defineProperty 只支持 DOM 节点啦，都是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 react-menu-aim 打造更友好的多级菜单</title>
    <link href="https://undefinedblog.com/react-menu-aim/"/>
    <id>https://undefinedblog.com/react-menu-aim/</id>
    <published>2015-07-11T18:59:44.000Z</published>
    <updated>2015-07-16T07:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>写过多级菜单的同学应该都知道当年亚马逊的黑科技：鼠标从一级菜单滑向二级菜单时，如果中间经过了另一个一级菜单，并不会马上切换。这也避免了用户想看二级菜单的时候，必须先精准的横向移动到对应二级菜单的不便。</p><p>详细的原理在<a href="http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown" target="_blank" rel="noopener">这篇博文</a> 里都有解释，本文不再赘述。简单地说，就是在一级菜单项 mouseenter 的时候，根据鼠标之前的移动坐标，判断用户当前是否是想移动到二级菜单。若是，则 setTimeout 一段时间，再重新判断；若不是，则直接激活当前一级菜单项。</p><p>一图胜千言：</p><p><img src="https://cloud.githubusercontent.com/assets/1336484/8591773/198d1d4a-265d-11e5-94b1-97071a591ab1.gif" alt="react-menu-aim"></p><p><a href="http://jasonslyvia.github.io/react-menu-aim/demo/index.html" target="_blank" rel="noopener">Demo</a></p><p>目前已经有人根据这个原理写了一个 jQuery 插件 <a href="https://github.com/kamens/jQuery-menu-aim/" target="_blank" rel="noopener">jQuery-menu-aim</a>，而我由于在最近的 React 项目中需要使用这个功能，就顺手写了一个 React 版本。</p><p>使用的方法也很简单，引入 <a href="https://github.com/jasonslyvia/react-menu-aim" target="_blank" rel="noopener">react-menu-aim</a> 作为一个 mixin，然后在 <code>componentWillMount</code> 的时候配置一下，最后在 render 的时候调用 mixin 提供的一些事件响应方法即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var React = require(&apos;react&apos;);</span><br><span class="line">var ReactMenuAim = require(&apos;react-menu-aim&apos;);</span><br><span class="line"></span><br><span class="line">var Menu = React.createClass(&#123;</span><br><span class="line">  // 使用 ReactMenuAim mixin</span><br><span class="line">  mixins: [ReactMenuAim],</span><br><span class="line"></span><br><span class="line">  componentWillMount: function() &#123;</span><br><span class="line">    // 在这里配置 ReactMenuAim</span><br><span class="line">    this.initMenuAim(&#123;</span><br><span class="line">      submenuDirection: &apos;right&apos;,</span><br><span class="line">      menuSelector: &apos;.menu&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 由于 ReactMenuAim 需要响应组件的 mouseenter 等事件，所以若你也需要</span><br><span class="line">  // 响应这些事件，可以把自己的 event handler 作为参数传给 ReactMenuAim</span><br><span class="line">  // 提供的 event handler。</span><br><span class="line">  //</span><br><span class="line">  // 例如下面就是组件自己的 event handler</span><br><span class="line">  handleSwitchMenuIndex: function(index) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // this.handleMouseLeaveMenu 和 this.handleMouseEnterRow 是 </span><br><span class="line">  // ReactMenuAim 提供的方法，让它们分别响应鼠标离开菜单和鼠标进入每一个</span><br><span class="line">  // 一级菜单选项的事件。</span><br><span class="line">  //</span><br><span class="line">  // 若 ReactMenuAim 判定应该激活当前 mouseenter 的一级菜单时，会调用</span><br><span class="line">  // 传入的回调。在这个例子里，就是我们自己的 this.handleSwitchMenuIndex 方法</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;menu-container&quot;&gt;</span><br><span class="line">        &lt;ul className=&quot;menu&quot; onMouseLeave=&#123;this.handleMouseLeaveMenu&#125;&gt;</span><br><span class="line">          &lt;li className=&quot;menu-item&quot; onMouseEnter=&#123;this.handleMouseEnterRow.bind(this, 0, this.handleSwitchMenuIndex)&#125;&gt;Menu Item 1&lt;/li&gt;</span><br><span class="line">          &lt;li className=&quot;menu-item&quot; onMouseEnter=&#123;this.handleMouseEnterRow.bind(this, 1, this.handleSwitchMenuIndex)&#125;&gt;Menu Item 1&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更多的配置项见 <a href="https://github.com/jasonslyvia/react-menu-aim" target="_blank" rel="noopener">github repo</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写过多级菜单的同学应该都知道当年亚马逊的黑科技：鼠标从一级菜单滑向二级菜单时，如果中间经过了另一个一级菜单，并不会马上切换。这也避免了用户想看二级菜单的时候，必须先精准的横向移动到对应二级菜单的不便。&lt;/p&gt;
&lt;p&gt;详细的原理在&lt;a href=&quot;http://bjk5.co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解 React 的 batchUpdate 机制</title>
    <link href="https://undefinedblog.com/understand-react-batch-update/"/>
    <id>https://undefinedblog.com/understand-react-batch-update/</id>
    <published>2015-06-22T06:43:02.000Z</published>
    <updated>2015-06-22T15:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前有篇文章写了「<a href="http://undefinedblog.com/why-react-is-so-fast/">为什么 React 这么快</a>」，其中说到一点很重要的特性就是 <code>batchUpdate</code>。我一直以为 batchUpdate 是 Virtual DOM 的什么黑科技，直到上周跑去支付宝跟承玉等大牛交流后才直到自己理解的有偏差。</p><p>废话少说，直接上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">var Parent = React.createClass(&#123;</span><br><span class="line">  getInitialState: function() &#123;</span><br><span class="line">     return &#123;</span><br><span class="line">       text: &apos;default&apos;</span><br><span class="line">     &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  handleChildClick: function()&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: Math.random() * 1000</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  render: function()&#123;</span><br><span class="line">    console.log(&apos;parent render&apos;);</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;parent&quot;&gt;</span><br><span class="line">       this is parent!</span><br><span class="line">       &lt;Child text=&#123;this.state.text&#125; onClick=&#123;this.handleChildClick&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var Child = React.createClass(&#123;</span><br><span class="line">  getInitialState: function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">     text: this.props.text + &apos;~&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  componentWillReceiveProps: function(nextProps) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: nextProps.text + &apos;~&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  handleClick: function()&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: &apos;clicked&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    this.props.onClick();</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  render: function() &#123;</span><br><span class="line">    console.log(&apos;child render&apos;);</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">     &lt;div className=&quot;child&quot;&gt;</span><br><span class="line">       I&apos;m child</span><br><span class="line">       &lt;p&gt;something from parent:&lt;/p&gt;</span><br><span class="line">       &lt;p&gt;&#123;this.state.text&#125;&lt;/p&gt;</span><br><span class="line">       &lt;button onClick=&#123;this.handleClick&#125;&gt;click me&lt;/button&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(&lt;Parent/&gt;, document.body);</span><br></pre></td></tr></table></figure><p><a href="http://jsbin.com/yaqimo/2/edit?js,console,output" target="_blank" rel="noopener">DEMO</a></p><p>当组件首次渲染时，console 输出内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent render</span><br><span class="line">child render</span><br></pre></td></tr></table></figure><p>下面考虑点击 <code>Child</code> 中的 button，问 console 中输出的内容是怎样的？</p><p>让我们看看 Child 的 <code>handleClick</code>，首先调用了一次 <code>setState</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">  text: &apos;clciked&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后调用了 Parent 的 <code>onClick</code> 回调。而 Parent 的 handleChildClick 方法更新了自己的 state，从而触发了新一轮的 render。</p><p>那么，console 中输出的内容莫非是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child render   // Child setState</span><br><span class="line">parent render  // Parent setState</span><br><span class="line">child render   // Parent state 更新，Child 跟着 re-render</span><br></pre></td></tr></table></figure><p>但实际情况是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent render</span><br><span class="line">child render</span><br></pre></td></tr></table></figure><p>我们预期的 Child 调用 setState 导致的 render 似乎并没有发生。</p><p>下面再来一个简单点的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line">  handleClick: function() &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: &apos;clicked&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    var newText = this.state.text + &apos; agian&apos;;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text: newText</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">//...</span><br></pre></td></tr></table></figure><p>如果我们把 Child 的 handleClick 改写成上面这样，render 的触发情况又是怎样的呢？Child 的 state 中 <code>text</code> 的值又是什么呢？</p><p>答案见 <a href="http://jsbin.com/yaqimo/3/edit?js,console,output" target="_blank" rel="noopener">DEMO</a>，本文不再赘述。</p><p>到这里，我们已经领会了 batchUpdate 的强大之处，但是 batchUpdate 究竟是怎么实现的呢？让我们深入到 React 的源码中一探究竟。</p><blockquote><p>以下内容由于本人能力及精力均有限，尚未深究，仅供参考。如有错误，尽请斧正！</p></blockquote><p>首先，我们在 Child 的 handleClick 中调用了 setState，其简化的调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this.setState</span><br><span class="line">...</span><br><span class="line">this.replaceState</span><br><span class="line">...</span><br><span class="line">将更新后的 state 保存为 this._pendingState</span><br><span class="line">...</span><br><span class="line">if (不是在 componentWillMount 的生命周期中)</span><br><span class="line">ReactUpdates.enqueneUpdate</span><br><span class="line">...</span><br><span class="line">将当前 component 存入 dirtyComponents 数组中</span><br><span class="line">...</span><br><span class="line">if (存在 callback)</span><br><span class="line">将 callback 保存到 component._pendingCallbacks 数组中</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一次 setState 调用就这么结束了，而下一行调用 <code>this.props.onClick()</code> 触发的也是 Parent 的 setState，整体调用栈类似。</p><p>那么问题来了，两次 setState 都是把变化存入一个 pending 数组中，那么变化最后究竟是怎么起作用的呢？</p><p>实际上我们看看一次事件触发的完整调用栈就能大概明白了。</p><p>当一次 DOM 事件触发后，ReactEventListener.dispatchEvent 方法会被调用。而这个方法并不是急着去调用我们在 JSX 中指定的各种回调，而是调用了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactUpdates.batchedUpdates</span><br></pre></td></tr></table></figure><p>这个方法就是 React 整个 batchUpdate 思想的核心。该方法会执行一个 transaction，而要执行的内容被定义在 handleTopLevelImpl，其实就是找到事件对应的所有节点并依次对这些节点触发事件。</p><p>在进一步介绍之前，我们需要先了解一下 Transaction。</p><p>React 为 Transaction 封装了一个简单的 Mixin，并在源码中生动的介绍了一个 Transaction 是怎么工作的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *                       wrappers (injected at creation time)</span><br><span class="line"> *                                      +        +</span><br><span class="line"> *                                      |        |</span><br><span class="line"> *                    +-------------------------------------+</span><br><span class="line"> *                    |                 v        |              |</span><br><span class="line"> *                    |      +---------------+   |              |</span><br><span class="line"> *                    |   +--|    wrapper1   -----+         |</span><br><span class="line"> *                    |   |  +---------------+   v    |         |</span><br><span class="line"> *                    |   |          +-------------+  |         |</span><br><span class="line"> *                    |   |     +----|   wrapper2  -------+   |</span><br><span class="line"> *                    |   |     |    +-------------+  |     |   |</span><br><span class="line"> *                    |   |     |                     |     |   |</span><br><span class="line"> *                    |   v     v                     v     v   | wrapper</span><br><span class="line"> *                    | +---+ +---+   +---------+   +---+ +---+ | invariants</span><br><span class="line"> * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained</span><br><span class="line"> * +-----------------&gt;-----&gt;|anyMethod-------------&gt;</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | +---+ +---+   +---------+   +---+ +---+ |</span><br><span class="line"> *                    |  initialize                    close    |</span><br><span class="line"> *                    +-----------------------------------------+</span><br><span class="line"> **/</span><br></pre></td></tr></table></figure><p>实际上，Transacation 就是给需要执行的函数封装了两个 wrapper，每个 wrapper 都有 initialize 和 close 方法。当一个 transaction 需要执行（perform）的时候，会先调用对应的 initialize 方法。同样的，当一个 transaction 执行完成后，会调用对应的 close 方法。</p><p>回到刚才的问题，pending 的状态究竟是怎么被改变成真正的状态的呢？其实在刚开始的时候，一个事件触发后 ReactEventListener.dispatchEvent 被调用，这个函数中调用了 batchingStrategy 的 batchUpdate 方法。而 batchingStrategy 中使用了一个 ReactDefaultBatchingStrategyTransaction 的示例 transaction， 那么这个名字超长的类究竟干了什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function ReactDefaultBatchingStrategyTransaction() &#123;</span><br><span class="line">  this.reinitializeTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assign(</span><br><span class="line">  ReactDefaultBatchingStrategyTransaction.prototype,</span><br><span class="line">  Transaction.Mixin,</span><br><span class="line">  &#123;</span><br><span class="line">    getTransactionWrappers: function() &#123;</span><br><span class="line">      return TRANSACTION_WRAPPERS;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意它被 assgin 的 getTransactionWrappers 方法，返回了一个常量 TRANSACTION_WRAPPERS。</p><p>看到这里你应该就明白了，这个常量里定义了最后把 pendingState 改写为真正的 state 的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var NESTED_UPDATES = &#123;</span><br><span class="line">  initialize: function() &#123;</span><br><span class="line">    this.dirtyComponentsLength = dirtyComponents.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  close: function() &#123;</span><br><span class="line">    if (this.dirtyComponentsLength !== dirtyComponents.length) &#123;</span><br><span class="line">      // Additional updates were enqueued by componentDidUpdate handlers or</span><br><span class="line">      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run</span><br><span class="line">      // these new updates so that if A&apos;s componentDidUpdate calls setState on</span><br><span class="line">      // B, B will update before the callback A&apos;s updater provided when calling</span><br><span class="line">      // setState.</span><br><span class="line">      dirtyComponents.splice(0, this.dirtyComponentsLength);</span><br><span class="line">      flushBatchedUpdates();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dirtyComponents.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var UPDATE_QUEUEING = &#123;</span><br><span class="line">  initialize: function() &#123;</span><br><span class="line">    this.callbackQueue.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: function() &#123;</span><br><span class="line">    this.callbackQueue.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];</span><br></pre></td></tr></table></figure><p>我们需要关注的就是 NESTED_WRAPPER 中的 close 方法，也就是这个方法指明了当所有的事件触发响应结束后，flushBatchUpdates()。至于究竟是怎么 flush 的，本文暂不深究。</p><p>纵观 React 源码，使用 Transaction 之处非常之多，React 源码注释中也列举了很多可以使用 Transaction 的地方，比如</p><ul><li>在一次 DOM reconciliation（调和，即 state 改变导致 Virtual DOM 改变，计算真实 DOM 该如何改变的过程）的前后，保证 input 中选中的文字范围（range）不发生变化</li><li>当 DOM 节点发生重新排列时禁用事件，以确保不会触发多余的 blur/focus 事件。同时可以确保 DOM 重拍完成后事件系统恢复启用状态。</li><li>当 worker thread 的 DOM reconciliation 计算完成后，由 main thread 来更新整个 UI</li><li>在渲染完新的内容后调用所有 <code>componentDidUpdate</code> 的回调</li><li>等等</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前有篇文章写了「&lt;a href=&quot;http://undefinedblog.com/why-react-is-so-fast/&quot;&gt;为什么 React 这么快&lt;/a&gt;」，其中说到一点很重要的特性就是 &lt;code&gt;batchUpdate&lt;/code&gt;。我一直以为 batchU
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>解决使用 ES6 写测试时 chai 的报错</title>
    <link href="https://undefinedblog.com/chai-throw-error-when-use-babel-transform-es6-syntax/"/>
    <id>https://undefinedblog.com/chai-throw-error-when-use-babel-transform-es6-syntax/</id>
    <published>2015-04-23T02:30:56.000Z</published>
    <updated>2015-04-23T02:38:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近基本所有的项目都开始使用 ES6 语法来写。一是因为很多 ES6 语法确实简洁很多（如箭头函数），二是因为向 ES5 甚至 ES3 兼容的 transpiler 都比较成熟，不用担心兼容性的问题。</p><p>但是最近在用 ES 6 写测试代码时，chai 会报如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Unable to access callee of strict mode <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>经过一番研究我发现如下几个点：</p><ol><li>chai 不支持 strict mode</li><li>Babel 在将 ES6 module 转换为 ES5 时会自动添加 <code>&quot;use strict&quot;;</code> 指令（这也是 ES 6 的规范）</li></ol><p>因为我的测试代码也是用 ES 6 编写，Babel 在转换时给测试代码添加了严格模式的指令，导致 chai 的 expect 方法报错了。</p><p>解决方法比较简单：</p><ol><li>在使用 Babel 转换 ES6 代码时可以传入参数 <code>{blacklist: strict}</code>，如果使用命令行，可以使用 <code>babel xxx.js --blacklist=strict</code> （在正常的业务代码中不建议使用该参数）</li><li>如果使用了 Webpack 或 Browserify，要在配置文件中忽略掉 <code>node_modules</code> 文件夹</li></ol><p>最近工作繁忙，博客更新的太慢……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近基本所有的项目都开始使用 ES6 语法来写。一是因为很多 ES6 语法确实简洁很多（如箭头函数），二是因为向 ES5 甚至 ES3 兼容的 transpiler 都比较成熟，不用担心兼容性的问题。&lt;/p&gt;
&lt;p&gt;但是最近在用 ES 6 写测试代码时，chai 会报如下错
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解 React 生命周期方法</title>
    <link href="https://undefinedblog.com/understabd-react-lifecycle/"/>
    <id>https://undefinedblog.com/understabd-react-lifecycle/</id>
    <published>2015-02-02T09:22:55.000Z</published>
    <updated>2015-02-02T09:22:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚接触 React 的时候就发现了 API 里有一系列的 <code>componentXXX</code> 方法，按照<a href="http://facebook.github.io/react/docs/component-specs.html" target="_blank" rel="noopener">官方文档</a>的说法，这些方法会在「应用程序生命周期的特定时间点」被执行。但是在实际写代码的过程中，这样模糊的说法还是不能解决所有的疑惑。且看下面的内容：</p><h2 id="mixin-中的方法先执行"><a href="#mixin-中的方法先执行" class="headerlink" title="mixin 中的方法先执行"></a>mixin 中的方法先执行</h2><p>考虑以下代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var DummyMixin = &#123;</span><br><span class="line">  componentDidMount: function()&#123;</span><br><span class="line">    console.log(&apos;mixin&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var DummyClass = React.createClass(&#123;</span><br><span class="line">  mixins: [DummyMixin],</span><br><span class="line">  </span><br><span class="line">  componentDidMount: function()&#123;</span><br><span class="line">    console.log(&apos;component&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  render: function()&#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将 <code>DummyClass</code> 渲染到 DOM 节点在 console 中输出的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mixin</span><br><span class="line">component</span><br></pre></td></tr></table></figure><p><a href="http://jsbin.com/zeqiqo/1/edit?html,js,console" target="_blank" rel="noopener">DEMO</a></p><p>因此可以确认如果在 mixin 中和组件中同时定义了某个生命周期方法，mixin 中的方法会先执行。</p><h2 id="重复-mount-一个组件"><a href="#重复-mount-一个组件" class="headerlink" title="重复 mount 一个组件"></a>重复 mount 一个组件</h2><p>考虑以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var DummyClass = React.createClass(&#123;</span><br><span class="line">  render: function()&#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(&lt;DummyClass /&gt;, document.body);</span><br><span class="line">React.render(&lt;DummyClass /&gt;, document.body);</span><br></pre></td></tr></table></figure><p>都有哪些生命周期方法被调用，它们的顺序又是怎样的呢？看答案之前先自己思考一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 第一次 render */</span><br><span class="line">getDefaultProps</span><br><span class="line">getInitialState</span><br><span class="line">componentWillMount</span><br><span class="line">render</span><br><span class="line">componentDidMount</span><br><span class="line">/* 第二次 render */</span><br><span class="line">componentWillReceiveProps</span><br><span class="line">shouldComponentUpdate</span><br><span class="line">componentWillUpdate</span><br><span class="line">render</span><br><span class="line">componentDidUpdate</span><br></pre></td></tr></table></figure><h2 id="从-mount-到-unmount"><a href="#从-mount-到-unmount" class="headerlink" title="从 mount 到 unmount"></a>从 mount 到 unmount</h2><p>考虑以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var DummyClass = React.createClass(&#123;</span><br><span class="line">  render: function()&#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.render(&lt;DummyClass /&gt;, document.body);</span><br><span class="line">React.unmountComponentAtNode(document.body);</span><br></pre></td></tr></table></figure><p>调用结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* mount */</span><br><span class="line">getDefaultProps</span><br><span class="line">getInitialState</span><br><span class="line">componentWillMount</span><br><span class="line">render</span><br><span class="line">componentDidMount</span><br><span class="line">/* unmount */</span><br><span class="line">componentWillUnmount</span><br></pre></td></tr></table></figure><p>这里再提一个小问题，先 mount 一个组件再 unmount 再 mount，生命周期方法的调用情况是怎样的？</p><h2 id="第三方代码控制生命周期"><a href="#第三方代码控制生命周期" class="headerlink" title="第三方代码控制生命周期"></a>第三方代码控制生命周期</h2><p>如果是你使用了 react-router 等第三方库来控制你组件的生命周期，你可能不能直观的掌握组件什么时候会被 mount，什么时候会被 unmount。</p><p>这个时候你可以使用 <a href="https://github.com/jasonslyvia/react-lifecycle" target="_blank" rel="noopener">react-lifecycle</a> mixin，将这个 mixin 添加到你需要观察的组件中，当任何生命周期方法被调用时，你都能在 console 中看到对应的日志。</p><p>当然，这个 mixin 不会输出 render 方法的调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚接触 React 的时候就发现了 API 里有一系列的 &lt;code&gt;componentXXX&lt;/code&gt; 方法，按照&lt;a href=&quot;http://facebook.github.io/react/docs/component-specs.html&quot; target=&quot;_
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图解 debounce 与 throttle 的区别</title>
    <link href="https://undefinedblog.com/debounce-and-throttle/"/>
    <id>https://undefinedblog.com/debounce-and-throttle/</id>
    <published>2015-01-25T13:41:43.000Z</published>
    <updated>2015-01-25T13:46:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在实现一些需要被频繁调用的函数时，我们通常都会使用 <code>debounce</code> 或 <code>throttle</code> 方法。在我的印象中，它们的作用就是减少函数被调用的次数，但具体有什么区别，却真的不能说清楚。</p><p>直到最近看了一篇精彩的<a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank" rel="noopener">博文</a>，用可视化的方法展示了两者的区别，很有启发性，值得参考。</p><p><img src="/content/images/2015/Jan/QQ20150125-1-2x.png" alt="debounce 与 throttle"></p><p>注意到上图，第一行 <code>Mousemove Events</code> 展示了 <code>mousemove</code> 事件触发的频率。第二行和第三行是分别使用 underscore 与 jQuery 的 debounce 方法(leading 参数为true，保证一开始先调用一次目标函数)后事件的触发频率。第四、五行则是 trailing 参数为 true（保证 delay 结束调用一次）的触发频率。与之对比的是最后三行，使用的是 throttle 方法。</p><p>首先我们的直观感觉是使用 debounce 方法相比于 throttle 方法事件触发的频率更低，但实际上不能这么理解。要解释上图的结果，首先需要了解 debounce 和 throttle 的原理。</p><p>当我们阅读 lodash 的代码时会发现，throttle 方法不过是 debounce 方法的一个修饰。也就是说，<em>.throttle 和 </em>.debounce 最终都会都会调用 debounce 方法。那么 debounce 究竟是如何工作的呢？</p><p>首先看 _.debounce 的 API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.debounce(func, delay, options);</span><br></pre></td></tr></table></figure><p>func 是需要被调用的目标函数，delay 是时间限制，options 是一系列的配置，为了简化问题，这里不多提。</p><p>当调用 _.debounce 后，会返回一个函数，这个函数在被调用时会生成一个 setTimeout(delayed, delay)。其中 delayed 又是一个内部方法，在 delayed 被调用时进行如下检测：当前时间 - 上次func被调用事件 是否 小于 0 或 大于 delay ？如果是则执行一次 func，记录并返回执行结果，同时更新上次被调用时间；如果不是则调用 setTimeout 进行下一次的判断。</p><p>因此，当你像下面这样绑定事件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(window).on(&apos;mousemove&apos;, _.debounce(moveHandler, 500));</span><br></pre></td></tr></table></figure><p>并频繁移动鼠标时，你会发现 moveHandler 压根没有被调用过！直到你停下来后，moveHandler 才会被调用一次。</p><p>至于 _.throttle 方法，只不过是多给 debounce 传了 maxWait、leading=true、trailing=true 选项，这些选项的意思是至少保证在每 maxWait 时间让 func 被调用一次。</p><p>说到这儿，你应该就明白了为什么会出现上图那样的调用情况。如果你频繁的移动鼠标，throttle 会保证在每 maxWait 时间调用 func 一次，而 debounce 如果没有明确设置 maxWait，是一直不会调用 func 直到你停止移动鼠标后才会调用一次。</p><blockquote><p>因此，可以笼统的说 <em>.throttle 就是设置了 leading=true, trailing=true 及 maxWait 的 </em>.debounce。</p></blockquote><p><strong>那什么时候该用 debounce 什么时候该用 throttle 呢？</strong></p><p>下面我列举了一些场景：</p><ul><li>input 中输入文字自动发送 ajax 请求进行自动补全： debounce</li><li>resize window 重新计算样式或布局：debounce</li><li>mouseleave 时隐藏二级菜单：debounce，并合理使用 cancel 方法</li><li>scroll 时更新样式，如随动效果：throttle</li></ul><p>最重要的还是理解两者对调用时间及次数上的处理，根据业务逻辑选择最合适的优化方案！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在实现一些需要被频繁调用的函数时，我们通常都会使用 &lt;code&gt;debounce&lt;/code&gt; 或 &lt;code&gt;throttle&lt;/code&gt; 方法。在我的印象中，它们的作用就是减少函数被调用的次数，但具体有什么区别，却真的不能说清楚。&lt;/p&gt;
&lt;p&gt;直到最近看了一篇精彩的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为什么 React 这么快？</title>
    <link href="https://undefinedblog.com/why-react-is-so-fast/"/>
    <id>https://undefinedblog.com/why-react-is-so-fast/</id>
    <published>2014-12-31T09:25:54.000Z</published>
    <updated>2014-12-31T09:25:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>第一次使用 React 的同学都会对 React.js 的文件大小感到隐隐的不安。的确，未压缩的代码有 450KB+，GZIP 后还有近 100KB，这么庞大的库会不会在性能上存在瓶颈呢？</p><p>其实在实际开发过程中，并没有感觉到我们基于 React 构建的 WebApp 有任何的性能瓶颈。按照 React 官方的说法，即使在 iOS 的 UIWebView 中（无法使用 JavaScript JIT 引擎），React 也能保证 60FPS 的更新率。</p><p>那么 React 是如何做到如此高效的呢，其核心开发者之一 Pete Hunt 在 <a href="http://www.quora.com/Pete-Hunt/Posts/React-Convincing-the-Boss" target="_blank" rel="noopener">Quora</a> 上针对这一问题做了阐述。</p><p>下面就我个人的理解结合 Pete Hunt 的回答，整理归纳了 5 点 React 如此高效的原因：</p><p><strong>1. React 的核心代码在开发过程中就考虑了编译器优化问题</strong></p><p>具体的优化措施包括使用对象池来避免频繁的垃圾回收（垃圾回收过程可能导致浏览器出现卡顿现象）、兼容 Google 的 <a href="https://developers.google.com/closure/compiler/" target="_blank" rel="noopener">Closure Compiler</a>以及保证代码被 JIT 正确的优化。</p><p><strong>2. 每一个 React 组件都有完整的生命周期</strong></p><p>组件的生命周期如 <code>getInitialState</code>、<code>componentWillMount</code> 等，这些生命周期方法保证所有对 DOM 的修改都是批量更新的（batch update）。这样你就可以避免读一次 DOM、写一次 DOM 再读一次 DOM 这样频繁触发 layout 的糟糕代码了。</p><p><strong>3. 强大的 Virtual DOM</strong></p><p>实际上，JavaScript 之所以让人感觉慢就是因为 DOM 操作慢。试想随便新建一个 DOM 元素就有无数个属性、方法、事件、回调，这样的性能损耗是不能接受的。当 state 发生改变时，React 提供的 <code>render</code> 方法并不会直接把你定义的 HTML 结构重新写进 DOM 中，而是在内部的 Virtual DOM 中进行 diff，再计算出需要更新的 DOM，最后再把这部分需要更新的 DOM 写入真正的 DOM 中。</p><p><strong>4. 高效的单向数据绑定</strong></p><p>写过 Angular 的同学都知道 Angular 提供的双向数据绑定用着很爽，但是当需要绑定的数据越来越多时，Angular 的脏值检测方法就显得力不从心了。而 React 提供的仅是单向数据绑定，这样的绑定并不会让你觉得不便，反而配合 React 自己的事件系统，用起来得心应手。</p><p><strong>5. 用于极致优化 shouldComponentUpdate()</strong></p><p>即使 React 提供了这么多性能优化的方法，你还是可以进一步优化你的组件的性能，这就是 <code>shouldComponentUpdate()</code> 方法。在这个方法中你可以根据新的 props 和当前 props 的差异对比确认当前这个组件是否需要更新。</p><p>有了以上 5 点优化，开发者无需担心如何优化 React 的性能，而可以更多的把精力集中在业务代码的实现上，从而真正实现高效的前端开发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次使用 React 的同学都会对 React.js 的文件大小感到隐隐的不安。的确，未压缩的代码有 450KB+，GZIP 后还有近 100KB，这么庞大的库会不会在性能上存在瓶颈呢？&lt;/p&gt;
&lt;p&gt;其实在实际开发过程中，并没有感觉到我们基于 React 构建的 Web
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Backbone 源码阅读笔记</title>
    <link href="https://undefinedblog.com/backbone-source-code/"/>
    <id>https://undefinedblog.com/backbone-source-code/</id>
    <published>2014-12-19T12:09:21.000Z</published>
    <updated>2014-12-24T09:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直在用 Backbone，却不明白具体的实现。都说 Backbone 的源码好读，因此特意花了一个下午通读一遍。以下为零星笔记：</p><p>###“多此一举”的 ctx</p><p>在 Backbone.Events 中绑定事件时，每一个事件的回调由三个部分组成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;callback: callback, context: context, ctx: context || this&#125;</span><br></pre></td></tr></table></figure><p>其中 callback 是用户调用 on 时传入的回调，context 是用户指定的回调调用时的 this，而 ctx 看起来跟 context 值一致，实则不然。</p><p>如果用户在使用 on 绑定事件时没有指定 context，在 trigger 时需要给 callback 指定 context，这个时候的 context 用的是上文中的 ctx 而不是 context，因为 ctx 可以保证有值。但是在 off 时，要与用户绑定时的 context 进行对比，所以使用的是 context 而不是 ctx。</p><p>###高效的调用函数</p><p>在使用 func.call 或 func.apply 调用函数时，使用数量明确的参数比直接传 arguments 效率要高。</p><p>Backbone 源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var triggerEvents = function(events, args) &#123;</span><br><span class="line">    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];</span><br><span class="line">    switch (args.length) &#123;</span><br><span class="line">      case 0: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx); return;</span><br><span class="line">      case 1: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1); return;</span><br><span class="line">      case 2: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;</span><br><span class="line">      case 3: while (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;</span><br><span class="line">      default: while (++i &lt; l) (ev = events[i]).callback.apply(ev.ctx, args); return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>可以发现其实 switch 中所有的 case 执行的工作和 default 中的工作是一致的，那为什么要这样写呢？一个简单的<a href="http://jsperf.com/limited-arguments-vs-arguments" target="_blank" rel="noopener">性能测试</a>就能看出来。</p><p>在需要使用 arguments 时，直接使用形参的效率要比将 arguments 转换为数组的效率要高太多太多。当然这样带来的问题就是 arguments 的个数必须固定，所以才有了上述 case 0、case 1、case 2 等写法。</p><p>###详解 set 方法</p><p>在 Backbone 中用到最多的可能就是 Model 中的 set 方法了，那么 set 究竟是如何工作的呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model.set(<span class="string">'a'</span>, <span class="number">1</span>, &#123;<span class="attr">silent</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">model.set(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">validate</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><p>以上是 set 方法暴露出的接口，而 Backbone 内部的处理流程大致如下：</p><ol><li>判断传入的第一个参数是不是 object，若是则说明第二个参数是对应的 options；若不是则将第一个参数和第二个参数拼装为 object。将这个 object 命名为 <code>attrs</code>，方便下文引用。</li><li>调用 Model._validate 进行验证（在 _validate 中若 options.validate 为非真值则直接返回 true 而不进行验证）</li><li>设置临时状态位 <code>changing</code> 为 this._changing 的值，同时设置状态位 <code>this._changing</code> 为 true（即初次 set 时 changing 为 undefined 而 this.chaning 为 true）</li><li>如果是初次 set，将当前的 attributes 保存到 this._previousAttributes，同时将 this.changed 置为 {}，用来后续判断哪些属性发生了变化</li><li>如果 set 的参数中有 key 为 <code>id</code> 的值，则 this.id 发生相应的改变</li><li>遍历 attrs 中的每一个属性 attr，将它与 this.attributes 中的对应属性进行深度比较（_.isEqual），判断属性是否发生改变，将改变的属性记录在 changes 数组中。同时再将 attr 与 this._previousAttributes 中的对应属性再进行一次深度对比，将改变的属性记录中 this.changed 中，若没有改变则尝试删除 this.changed 中对应的 key</li><li>判断 options 中是否有 <code>{unset: true}</code> 的设置，若有，则把 this.attributes 中 attrs 里指定的所有 key 都删除</li><li>判断 options 中是否有 <code>{silent: true</code> 的设置，若没有，则分别触发 changes 数组中的一个 key 对应的 change 事件，同时 <code>this._pending = options</code>（后续步骤使用）</li><li>判断 <code>changing</code> 状态位是否为 true，若是则返回 this（这一步主要是考虑到步骤 8 中触发的 change 事件会再次导致 set 方法的调用，但是在后续的 set 调用中，由于 <code>this.changing</code> 已经设为 true（见步骤3）， <code>changing = this.changing</code> 也为 true， 所以后续 set 方法走到这一步就会结束） </li><li>判断 options.silent 是否为 true，若不是则将 this._pending 置为 false，同时触发 change 事件，并不断循环，直到 this._pending 为 false 为止</li><li>将 this._changing 和 this._pending 设为 false，返回 this，结束</li></ol><p>由此可见，一个小小的 set 方法暗藏了不少玄机啊！</p><p>*步骤 10 存疑，详见 <a href="http://stackoverflow.com/questions/27630751/why-there-is-a-while-loop-in-backbones-set-method" target="_blank" rel="noopener">stackoverflow 提问</a></p><h3 id="零星片段"><a href="#零星片段" class="headerlink" title="零星片段"></a>零星片段</h3><ul><li>cid 为 Backbone 自动为 Model 或 View 实例生成的 id（<code>this.cid = _.uniqueId(&#39;c&#39;)</code>），主要用于内部标示；id 对应的是 Model 在数据库中储存的 id，Backbone 会根据一个 Model 是否用于 id 来判断这个 Model 是不是新建的；idAttribute 默认值为 <code>&#39;id&#39;</code>，用于表示 id 这个字段的 key，比如你的 Model 是表示一本书，那么你的 id 可能叫做 <code>bookId</code>，因此可以将 <code>idAttribute</code> 设为 <code>bookId</code>。</li><li>Events 中的 all 事件，其实就是在执行 trigger 时不仅把当前要 trigger 的事件回调找出来调用一遍，同时还把监听 all 这个事件的回调找出来调用一遍。因此如果你 trigger(‘all’)，会发现 all 这个事件的回调被执行了两次。</li><li>Model 中的 collection 属性一般无需手动设置，当你把 Model 添加进 Collection 时 Backbone 会自动帮你把 model.collection 设为当前 Collection。</li><li>Collection 其实就是 Backbone 自己维护的一个类似数组的数据结构，核心数据是 collection.models，此外提供了一系列类似数组的方法，如 pop、shift 等。</li><li>对 Collection 的操作（add、remove、destory）等并不直接触发 Collection 对应的事件，而是通过触发 Collection 中 model 相应的事件，再在 model 中监听 all 事件，最后在 all 事件的回调中触发 Collection 相应的事件。</li><li>Backbone.View 真的好轻好轻……</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直在用 Backbone，却不明白具体的实现。都说 Backbone 的源码好读，因此特意花了一个下午通读一遍。以下为零星笔记：&lt;/p&gt;
&lt;p&gt;###“多此一举”的 ctx&lt;/p&gt;
&lt;p&gt;在 Backbone.Events 中绑定事件时，每一个事件的回调由三个部分组成&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅析 Facebook Flux 架构</title>
    <link href="https://undefinedblog.com/facebook-flux/"/>
    <id>https://undefinedblog.com/facebook-flux/</id>
    <published>2014-11-05T15:48:59.000Z</published>
    <updated>2015-03-11T06:25:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>在公司的项目里使用 React 解决 View 层问题的时候，我们让 Backbone 来扮演 Model 层的角色。其实 Facebook 自己也提出了一套完整的解决方案 —— <a href="http://facebook.github.io/flux/" target="_blank" rel="noopener">Flux</a>。不过由于其思路太过新颖，我们没有在生产环境中使用。</p><p>项目开发完毕回头看看 Flux，发现它的<strong>单向数据流(unidirectional data flow)</strong>思想还是很值得借鉴的，不过为了实现单向数据流，Flux 会迫使你把代码拆分的非常别扭。</p><p>下面就我自己浅显的认识，来分析一下 Flux 架构的运作方式、特点、与传统 MVC 方式的比较。</p><blockquote><p>阅读本文需要一定的 React 基础</p></blockquote><p>##Flux 基础概念</p><p>首先，Flux 不是一个框架（Framework）或库（Library），而是一种架构（Architecture）。这一点不要搞混，对于理解下面的内容会有所帮助。</p><p>其实看完 Flux 官网的 Overview，我还是没能很好的理解 Flux 中几个关键的概念 —— Dispatcher、Action、Store —— 之间的关系。最后我发现，还是直接看源码来的更加清晰。如果你希望能快速理解 Flux，可以先看完 Overview，然后直接看 <a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc/" target="_blank" rel="noopener">TODO 的例子</a>。</p><p>下面是我看完 Flux 两个官方例子（TODO 和 Chat）后总结的 Flux 运作流程图：</p><p><img src="/content/images/2015/03/Flux--1-.png" alt="Flux 架构流程图"></p><p>可以看到其中主要有如下几个概念：</p><ul><li>Controller-View ：整个 App 的入口，监听 Store 变化以获取新的数据，重新 render 自己及子 Component</li><li>React Component：从 Controller-View 获取 props，渲染自己，同时响应事件</li><li>Action： 扩展自 Dispatcher，抽象封装 Component 中可能出现的操作，当响应 DOM 事件时调用 Action 中对应的方法</li><li>Dispatcher： 一个事件分发控制器，通过 register 和 dispatch 方法来处理事件（一般不直接使用，建议直接阅读源码，简单易懂）</li><li>Store：维护数据，只有 getter 没有 setter，提供一系列 mutate 数据的方法</li></ul><p>至于和 Server 端交互的问题，这里不是重点，就不再赘述。</p><p>##Flux 运行机制</p><p>明确了上述几个概念点后，让我们从实际应用出发，来一步步分解 Flux 的运作方式。</p><p>首先当程序开始 bootstrap，先会使用 <code>React.renderComponent</code> 方法渲染 Controller-View 到某个 DOM 节点。其实 Controller-View 可以理解为所有组件的入口，类似一般 React 项目中的 <code>App</code> 或者 <code>Home</code> Component。不同的是，在 React 中<strong>有且只有</strong> Controller-View 负责监听 Model 层（也就是 Store）的变化，同时根据在变化发生后的新数据重新渲染自己及自己的子组件。</p><p>上面说到 Controller-View 需要监听 Store 变化，这个过程是通过 Store 暴露的接口实现的。Store 会扩展 node 中的 EventEmitter，以此来实现事件的 <code>on</code> 及 <code>emit</code>。那么 Store 怎么知道要更新数据呢，这里就要提到 Action。</p><p>Action 在上面说了扩展自 Dispatcher，而 Dispatcher 提供了注册监听事件的方法 <code>register</code>。因此 Store 在初始化的时候会调用 <code>Action.register()</code> 来注册一个回调函数，这个函数当 Action 接收到事件时会触发。</p><p>这里需要详细说说这个回调函数。如果你仔细看上面的示意图会发现，Action 指向 Store 的箭头上写了 <code>dispatch</code> 并带了一个 <code>payload</code>。 dispatch 是 Dispatcher 提供的方法，用于触发一个事件，而 payload 就是这个事件包含的有效信息（大概可以把 payload 理解成传统 DOM 事件中回调函数里的那个 event 对象？）。</p><p>通常 Store 在调用 Action.register 注册回调时的函数长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">payload</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (payload.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'create'</span>:</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'delete'</span>:</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 Action 传给 Store 的 <code>payload</code> 又是哪来的呢？（故事发展到这里终于要产生闭环了……）没错，就是 React Component 中响应各种事件时调用的。</p><p>所以一个精简的结构是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React Components --&gt; DOM 事件(payload形如 &#123;type:&apos;click&apos;, id: 42&#125;) --&gt; Action(dispatch 方法) --&gt; Store(注册的回调拿到了 payload，开始判断如何 mutate 数据，mutate 完之后触发 change 事件) --&gt; Controller-View(之前监听了 change 事件，发现数据更新了，那重新 render 一下吧) --&gt; React Components(parent 传来的 props 变了，重新 render 一下吧)</span><br></pre></td></tr></table></figure><p>这样，Flux 所一直倡导的<strong>单向数据流</strong>终于形成了闭环。从 DOM 事件到 dispatch 到 Store 响应事件到触发 change 到 View 监听更新并重新 render 自己。</p><p>##Flux 的特点</p><p>其实我相信没有仔细研究过 Flux 的同学即使看到这里也不一定完全明白 Flux 有什么特别之处。下面我简单罗列一下 Flux 的独到之处，并与 Backbone + React 的模式进行对比，以便更好的体现 Flux 的特点。</p><ol><li>Model 层没有 setter，不暴露任何改变数据的接口给外部</li><li>只有在最顶层的 Controller-View 响应 Model 的改变，子组件只能接受父组件传来的 props，不单独响应 Model 改变，也不能改变 Model</li><li>所有的事件统一到 Action 处理，不同于 Pub/Sub 模式的是，事件本身不区分类型，回调函数通过 Action.register 注册后所有 Action.dispatch(payload) 的事件都会触发回调函数</li><li>回调函数根据 payload 中的信息来确定自己是否需要响应这个事件</li><li>Store 之间的依赖关系可以通过 Dispatcher.waitFor 方法解决</li></ol><p>以上是我认为 Flux 不同与其他架构的 4 点内容，下面将 Flux 与 React + Backbone 方式进行简单的对比（求好用的 Markdown table 解决方案……）：</p><p><img src="/content/images/2014/Nov/QQ20141105-1-2x-2.png" alt=""></p><p>其中关于依赖需求的解释如下，model.trigger(‘someEvent’)，有两个组件 A、B 都响应 someEvent，我们希望 A 处理完之后 B 再处理。这个时候我能想到的解决方法就是先触发一个 preSomeEvent 的事件，让 A 监听 pre- 事件，B 监听 someEvent。</p><p>这一点可能因为我还没有很好的找到解决 Backbone 依赖的处理方法，所以对比仅供参考。(Backbone.Radio 或 Backbone.Wreqr？)</p><p>##Flux 小结</p><p>通过上面的对比还是可以发现，Flux 通过严格的控制数据的更新来实现单向数据流，这样的好处是你能清晰的掌握数据的改变方式及相应代码的位置。保证自己的程序不会因为业务的发展变得越来越臃肿（试想每个 Component 都能改变数据，这样在一个项目有几十上百个 Component 的情况下每个 Component 都可能改变了数据，那处理起来可就麻烦大了！）</p><p>当然，这种模式带来的问题也显而易见，因为数据都在 Store 更新，所有的事件都要定义在 Action 中，开发过程中处理需求就变得不那么灵活。新增一个 DOM 响应事件要同时修改 Component（View层）、Action 和 Store（回调中多判断一个 payload 的 type）。</p><p>同时，Store 向 Action 注册回调时通过 switch … case … payload 来区分事件会使得 Store 中的代码变得较为臃肿，这与 Backbone 使用的 Pub/Sub 方法有着巨大的差别。</p><p>Flux 还存在另一个问题，通常一个程序中不仅仅只有一种数据结构，因此必然会出现多个 Store。那么一个 Component 可能就需要监听多个 Store 的变化。如果某一个 Store 只在 Controller-View 的孙子的孙子的孙子的孙子节点才可能使用到，Flux 模式这种从顶部一层层传下来的方式也不见得会更加高效。（Flux 并不禁止有多个 Controller-View，但是很明显这样违背了 Flux 单向数据流的设计初衷，关于这一点目前似乎还没有很好的解决方法）</p><p>总的来说，Flux 看起来是把开发的模式变复杂了，但是通过严格的数据流向限制保证了程序在走向复杂化的过程中（scale）不会失去控制。如果你的程序可能会十分复杂，那么 Flux 也许值得你一试！</p><p>PS. 后续会尝试用 Flux 构建一个 Chrome 插件</p><p>##参考引用</p><ol><li><a href="http://facebook.github.io/flux/" target="_blank" rel="noopener">Flux 官网</a></li><li><a href="http://facebook.github.io/react/" target="_blank" rel="noopener">React 官网</a></li><li><a href="http://undefinedblog.com/something-about-payload/">代码里的 payload 是什么意思</a></li><li><a href="https://github.com/facebook/flux/tree/master/examples/" target="_blank" rel="noopener">Flux-example</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在公司的项目里使用 React 解决 View 层问题的时候，我们让 Backbone 来扮演 Model 层的角色。其实 Facebook 自己也提出了一套完整的解决方案 —— &lt;a href=&quot;http://facebook.github.io/flux/&quot; targe
      
    
    </summary>
    
    
  </entry>
  
</feed>
