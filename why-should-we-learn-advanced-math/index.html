<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>大学教的数学有什么用[程序员篇] | undefined | everything starts &amp; ends</title>

  
  <meta name="author" content="jasonslyvia">
  

  
  <meta name="description" content="这篇文章是对吴军所著《数学之美》一书的总结和归纳，更是一个准程序员在经历了三年苦恼的大学数学学习后的反思和感慨：原来数学的作用如此之大！倘若我有机会在大一时就拜读此书，那大学里学习的「高等数学」、「线性代数」、「离散数学」和「概率论」对我来说将远不会那么痛苦。可惜世上永远没有后悔药，如今（大三）再看">
  

  
  
  <meta name="keywords" content="概率论,离散数学,程序员,线性代数,高等数学">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="大学教的数学有什么用[程序员篇]"/>

  <meta property="og:site_name" content="undefined"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="undefined" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">undefined</a>
    </h1>
    <p class="site-description">everything starts &amp; ends</p>
  </div>
  <nav class="site-navigation">
    <ul class=" dim">
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>


    <main class="site-main posts-loop">
    <article class=" single-post">

  
    
    <h3 class="article-title"><span>大学教的数学有什么用[程序员篇]</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/why-should-we-learn-advanced-math/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-10T21:39:10.000Z">
          2013-05-11
        </time>
      </a>
      <a href="https://github.com/jasonslyvia/undefinedblog/tree/master/source/_posts/大学教的数学有什么用-程序员篇.md" target="_blank" style="margin-left: 10px" rel="nofollow">查看源码</a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>这篇文章是对吴军所著《数学之美》一书的总结和归纳，更是一个准程序员在经历了三年苦恼的大学数学学习后的反思和感慨：<strong>原来数学的作用如此之大！</strong>倘若我有机会在大一时就拜读此书，那大学里学习的「高等数学」、「线性代数」、「离散数学」和「概率论」对我来说将远不会那么痛苦。可惜世上永远没有后悔药，如今（大三）再看这篇文章，只剩感叹、思考，和感叹。</p>
<p>下面的内容我将根据不同的学术背景进行分类，分别阐述「高数」能干什么、「离散数学」能干什么等。因为我本人在这些科目上并没有取得很好的成绩，因此在总结归纳的过程中如果有任何不严谨甚至是错误的地方，还请多多指正！</p>
<p>在正文开始之前，最后啰嗦一句，如果你学的是「软件工程」、「计算机科学与技术」、「通信工程」等专业，并苦恼于这些数学知识，那么千万不要犹豫，马上去读《数学之美》吧！</p>
<p style="text-align: center;"><img class="aligncenter" title="数学之美" alt="数学之美" src="http://undefinedblog.com/wp-content/uploads/2013/05/s9114855.jpg" width="309" height="432"></p>

<p></p><h2>高等数学</h2><br>高等数学是一切知识的基石，虽然《数学之美》中的内容大多和「概率论」和「离散数学」有关，但是在涉及到一些基本计算的时候，用的还是高等数学的知识。因此学好高等数学才能更好的理解数学的美妙之处，学好高等数学就相当于掌握了一门工具。<p></p>
<p></p><h2>概率论</h2><br>概率论这门课在刚开始学习的时候，感觉特别简单，跟高中讲的知识几乎没有区别。就当我掉以轻心的时候，突然发现老师讲的内容已经听不懂了……<p></p>
<p style="text-align: center;"><img class="size-full wp-image-207046 aligncenter" alt="老湿，你在讲什么……" src="http://undefinedblog.com/wp-content/uploads/2013/05/Forever_Alone.jpg" width="300" height="348"></p>

<p></p><h3>自然语言处理</h3><br>所谓的自然语言处理，核心就是<strong>让计算机「理解」自然语言</strong>，并对这些自然语言进行相应的处理，比如语音识别、机器翻译等。关于「让计算机理解自然语言」这件事，科学家们经历了很长的一个探索的过程，甚至有好几十年是在做无用功，具体的故事请自行翻阅《数学之美》，这里就不偏题了。<p></p>
<p>那么自然语言处理究竟和「概率论」有什么关系呢？因为让计算机真正的像人那样去理解自然语言是效率不高而且很难的事，真正有效的方法是通过统计和概率的知识让计算机估算一个句子的合理性。<a title="贾里尼克 维基百科词条" href="http://en.wikipedia.org/wiki/Frederick_Jelinek" target="_blank">贾里尼克</a>（Frederick Jelinek）提出了一个方法来让计算机判断一个句子合理的概率，即在所有的有效文本（术语为语料库）中统计这个句子的所有序列出现的次数。但是因为条件概率在样本过大后计算起来十分麻烦，马尔科夫（Andrey Markov）提出了一种简化方法，<strong>即假设一个词语在某个句子中出现的概率只跟它的前一个词语有关</strong>，这样在计算条件概率时就简化了很多。这个模型被称为<strong>马尔科夫模型</strong>，在自然语言处理中，这个模型叫做<strong>二元模型（Bigram Model）</strong>。</p>
<p>因此，一个复杂的自然语言处理问题，最后被简化为计算单词序列在已知文本中的出现顺序，这么巧妙的设计能不让人感叹吗！</p>
<p>如果我们把马尔科夫模型的假设做一些改变，假设一个单词的出现概率跟它前面的两个词语有关，这样得到的计算结果将更加精确，但是计算量也会指数型的增加。</p>
<p></p><h3>中文分词与手写体识别</h3><br>给定的一句话，怎么快速的划分出所有的词语呢？比如<p></p>
<p><blockquote>中国航天官员应邀到美国与太空总署官员开会。</blockquote><br>可以划分为</p>
<p><blockquote>中国 / 航天/ 官员 / 应邀 / 到 / 美国 / 与 /太空 / 总署 / 官员 / 开会。</blockquote><br>问题在于计算机本身并不理解句子的意思，它怎么能把一个句子划分成上面的形式呢？答案很简单，还是利用概率和统计的知识。假设一个句子 S 有很多种分词方法，那<strong>最佳的分词方法应该保证分词后这个句子出现的概率最大</strong>。只要利用上面说到的马尔科夫模型对每种分词的句子计算概率，就能知道哪种分词效果最好了。</p>
<p></p><h3>机器翻译中的二义性解决</h3><br>在翻译美国前总统小布什的名字 Bush 时，计算机怎么知道将这个词翻译为「布什」而不是「灌木丛」呢？简单的说，就是利用<strong>互信息</strong>（用来量化两个随机事件相关性<strong>）</strong>。我们现在大量的现有文本中找到和「Bush」这个词同时出现在文本中最多次数的词有哪些，比如「国会」、「华盛顿」等。在翻译的过程中遇到「Bush」这个词时，如果在上下文中出现了有互信息的词汇，那么这个时候「Bush」很可能值得就是乔治·布什了。<p></p>
<p></p><h2>离散数学</h2><br>离散数学的知识包括了数理逻辑、集合论、图论和近世代数四个分支。<p></p>
<p></p><h3>建立索引</h3><br>为什么需要索引？你在使用 Windows 自带的搜索功能时，也会经常看到系统提示该磁盘尚未建立索引。建立索引的目的在于更方便的定位和查找，那么计算机是如何建立索引的呢，答案是依靠<strong>布尔代数</strong>的知识（没错，就是 true 和 false）。<p></p>
<p>假设有 n 个网页，我们用长度为 n 的一维数组表示这些网页中是否含有关键词「数学」，若有则该位置为 1，否则为 0。比如第 1、3、5 个网页含有关键词「数学」，那么这个数组就是</p>
<p><blockquote>[1, 0, 1, 0, 1, 0, 0, 0, ……]</blockquote><br>按照这样的方法，对所有的关键词都建立一个数组。当我们需要查询某个内容，比如「数学 博客」时，只需要找到「数学」和「博客」分别对应的数组，让它们进行按位与操作，得到的新数组中结果为 1 的元素（网页）就是我们要找的内容了。</p>
<p></p><h3>网络爬虫</h3><br>网络爬虫指的是那些不断访问和下载一个网站中的所有网页的计算机程序，各大搜索引擎都有自己的爬虫（或称蜘蛛，Spider），像 Google Spider，Baidu Spider 等。那么如何保证能把一个网站中的所有网页都一个不漏的下载了呢？我们需要用到图论中的遍历算法。<p></p>
<p>一般来说网络爬虫在下载一个网站时会用到广度优先的遍历算法，这是因为对于一个网站来说，在首页的链接通常是比较重要的，因此应该优先访问和下载。而广度优先的遍历算法就是，从某一个节点开始，访问所有跟这个节点直接相连的节点，在确保所有直接相连的访问节点都访问过后，再从一个直接相连的节点重复执行该操作，直到将所有节点都访问了一遍。</p>
<p>如果我没有解释清楚，请参考<a title="广度优先搜索" href="https://zh.wikipedia.org/zh/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank">广度优先算法维基百科词条</a>。</p>
<p></p><h2>线性代数</h2><br>一提到线性代数，想到的总是各种各样的矩阵。那我们乘来乘去的这些矩阵，究竟有什么作用呢？<p></p>
<p></p><h3>PageRank 算法</h3><br>如果你了解过 SEO 相关的知识，肯定能知道 Google 所谓 PR 值的说法，这里说的 PR 就是 PageRank。Google 就是依靠 PageRank 算法，把质量高的网页排在搜索结果的前面，帮助用户更好更快的找到想要的信息。那么 PageRank 算法和线性代数有啥关系呢？<p></p>
<p>PageRank 算法的核心思想是，一个网页的质量由互联网中链接向这个网页的网页的权重之和决定。比方说大家在写文章找引用的时候都喜欢贴维基百科的链接，那么维基百科对应的 PageRank 就会很高。那么在一开始的时候，如何确定每个网页的权重呢？</p>
<p>假设一开始所有的网页排名相同、权重相同，此时可以获得的数据只有各个网页之间互相链接的关系和次数。假设网页直接的链接关系为一个矩阵 A，其中第 amn 个元素代表着第 m 个网页指向第 n 个网页的链接数。我们需要获取的内容为所有网页的排名，用一个向量 B 表示， B = (b1, b2, …, bn)。目前 A 是已知的，而 B 是未知的，我们就不断的将 A·B 以获得新的 B 向量，直到两次获得的 B 向量的差距在一个可接受的范围内时，网页的排名就新鲜出炉了。</p>
<p>（未完待续）</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/概率论/">概率论</a><a href="/tags/离散数学/">离散数学</a><a href="/tags/程序员/">程序员</a><a href="/tags/线性代数/">线性代数</a><a href="/tags/高等数学/">高等数学</a>
    </span>
    

    </div>

    
  </div>
</article>

  
	<section id="comments" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'undefinedblog';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>





    </main>

    <footer class="site-footer">
  <p class="site-info">
    Powered by <a href="https://hexo.io/" target="_blank rel="nofollow"">Hexo</a> and
    Theme adapted from <a href="https://github.com/CodeDaraW/Hacker" target="_blank" rel="nofollow">Hacker</a>
    </br>
    
    &copy; 2017 jasonslyvia
    
  </p>
</footer>

    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-50332938-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>