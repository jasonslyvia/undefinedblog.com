<!DOCTYPE HTML>
<html lang="zh-hans">
<head>
  <meta charset="utf-8">
  
  <title>ReactRouter 4 前瞻 | undefined | everything starts &amp; ends</title>

  
  <meta name="author" content="jasonslyvia">
  

  
  <meta name="description" content="要问用 React 技术栈的前端同学对哪个库的感情最复杂，恐怕非 ReactRouter 莫属了。早在 React 0.x 时代，ReactRouter 就凭借与 React 核心思想一致的声明式 API 获得了大量开发者的喜爱。后续更是并入 reactjs group 并有 React 核心开发成">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
  <link rel="manifest" href="/favicon/manifest.json">
  <link rel="mask-icon" href="/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <meta property="og:title" content="ReactRouter 4 前瞻"/>

  <meta property="og:site_name" content="undefined"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="undefined" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">undefined</a>
    </h1>
    <p class="site-description">everything starts &amp; ends</p>
  </div>
  <nav class="site-navigation">
    <ul class=" dim">
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/subscribe">订阅</a></li>
      
    </ul>
  </nav>
</header>


    <main class="site-main posts-loop">
    <article class=" single-post  single-page">

  
    
    <h3 class="article-title"><span>ReactRouter 4 前瞻</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/reactrouter-4-foresee/" rel="bookmark">
        <time class="entry-date published" datetime="2016-09-17T20:44:57.000Z">
          2016-09-17
        </time>
      </a>
      <a href="https://github.com/jasonslyvia/undefinedblog/tree/master/source/_posts/ReactRouter-4-前瞻.md" target="_blank" style="margin-left: 10px" rel="nofollow">查看源码</a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>要问用 React 技术栈的前端同学对哪个库的感情最复杂，恐怕非 ReactRouter 莫属了。早在 React 0.x 时代，ReactRouter 就凭借与 React 核心思想一致的声明式 API 获得了大量开发者的喜爱。后续更是并入 reactjs group 并有 React 核心开发成员参与，俨然是 React 官方路由套件一样的存在。</p>
<p>然而从 1.x 版本起，ReactRouter 的洪荒之力就开始慢慢爆发，目前最稳定的版本已经是  <code>2.8.1</code>，而下一个正式版本将是 —— 没错，正如你在标题里看到的那样 —— <code>4.0.0</code>。先收拾一下你崩溃的心情，让我们来看看这一切到底是怎么回事。</p>
<h2 id="ReactRouter-3-去哪儿了"><a href="#ReactRouter-3-去哪儿了" class="headerlink" title="ReactRouter 3 去哪儿了"></a>ReactRouter 3 去哪儿了</h2><p>从 <code>2.x</code> 直接跨入 <code>4.x</code>，ReactRouter 的 maintainer 数学还不至于那么差，那这一切都是为什么呢？事实上 <code>3.x</code> 版本相比于 <code>2.x</code> 并没有引入任何新的特性，只是将 <code>2.x</code> 版本中部分废弃 API 的 warning 移除掉而已。按照规划，没有历史包袱的新项目想要使用稳定版的 ReactRouter 时，应该使用 ReactRouter 3.x。</p>
<p>目前 <code>3.x</code> 版本也还处于 beta 阶段，不过会先于 <code>4.x</code> 版本正式发布。<strong>如果你已经在使用 <code>2.x</code> 的版本，那么升级 <code>3.x</code> 将不会有任何额外的代码变动。</strong></p>
<h2 id="为什么又要大改-API"><a href="#为什么又要大改-API" class="headerlink" title="为什么又要大改 API"></a>为什么又要大改 API</h2><p>ReactRouter 的 API 是出了名的善变，这一点我已经在<a href="https://undefinedblog.com/react-v0-14/">之前的博文</a>中吐槽过一次了。没想到连 React 都稳定的在 <code>15.x</code> 版本中维护了这么久，ReactRouter 还是想要搞点大新闻。</p>
<p>根据 ReactRouter 核心开发者 <a href="https://github.com/ryanflorence" target="_blank" rel="noopener">ryanflorence</a> 的说法，ReactRouter 4.x 之所以要大刀阔斧的修改 API，主要是为了『声明式的可组合性（Declarative Composability）』。怎么理解声明式的可组合性呢？实际上当你在写 React 组件时，就不知不觉的利用了这一特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComponentA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;A&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ComponentB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;B&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Page</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;&lt;ComponentA /&gt;&lt;ComponentB /&gt;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如上面的代码片段，在 Page 组件中你可以方便的将任意组件在 render 方法中渲染出来。但是这种特性遇到 ReactRouter 时，你只能把匹配当前路由的组件用<code>this.props.children</code>（最早的时候是 <code>this.props.routerHandler</code>，有多少人还有印象）渲染 。</p>
<p>此外，ReactRouter 虽然宣称是声明式的路由库，但仍然提供了不少非声明式的 API，其中路由组件的生命周期方法就是最典型的例子。其实我们不难想到，明明用来渲染的 React 组件本身已经有了一套完备的生命周期方法（componentWillMount、componentWillUnmount 等），为什么还需要 ReactRouter 提供的什么 <code>onEnter</code> 和 <code>onLeave</code> 呢？</p>
<p>当然，这一切都是 ryanflorence 个人的说法，不知道又有多少人真的会为了追求纯正的 declarative 花时间去重构代码兼容 ReactRouter 4 呢？</p>
<h2 id="ReactRouter-4-有什么变化"><a href="#ReactRouter-4-有什么变化" class="headerlink" title="ReactRouter 4 有什么变化"></a>ReactRouter 4 有什么变化</h2><p>虽然目前还是 alpha 版本，但是 ReactRouter 4 的 API 已经有了雏形，其<a href="https://react-router-website-xvufzcovng.now.sh/" target="_blank" rel="noopener">官方文档</a>也有不少带 demo 的例子，下面简单总结一下 ReactRouter 4 的变化。</p>
<h3 id="更少的-API"><a href="#更少的-API" class="headerlink" title="更少的 API"></a>更少的 API</h3><p>先来看看目前 ReactRouter 2 的 API 列表：</p>
<p><img src="http://ww3.sinaimg.cn/mw690/831e9385gw1f7xaeadze7j209d0j5t9v.jpg" alt="ReactRouter 2.x API 列表"></p>
<p>再看看 4.x 计划中的 API：</p>
<p><img src="http://ww3.sinaimg.cn/mw690/831e9385gw1f7xaf8ju4lj204406f3yj.jpg" alt="ReactRouter 4.x API 列表"></p>
<p>直观看起来 API 确实少了不少，但这也意味着使用了被废弃的 API 将会有更大的重构工作量。不，实际上即使用了没有被废弃的 API，也会有很大的重构工作量。但是对于新手来说，学习成本相对会比较低。</p>
<h3 id="lt-Router-gt-变身为容器"><a href="#lt-Router-gt-变身为容器" class="headerlink" title="&lt;Router&gt;变身为容器"></a>&lt;Router&gt;变身为容器</h3><p>在目前的 API 中，&lt;Router&gt; 组件的 children 只能是 ReactRouter 提供的各种组件，如 <code>&lt;Route&gt;、&lt;IndexRoute&gt;、&lt;Redirect&gt;</code>等。而在 ReactRouter 4 中，你可以将各种组件及标签放进 <code>&lt;Router&gt;</code> 组件中，他的角色也更像是 Redux 中的 <code>&lt;Provider&gt;</code>。</p>
<p>不同的是 <code>&lt;Provider&gt;</code> 是用来保持与 store 的更新，而 <code>&lt;Router&gt;</code> 是用来保持与 location 的同步。</p>
<p>以下为新版 ReactRouter 可能的用法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;Accounts&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li&gt;&lt;Link to="/</span>netflix<span class="string">"&gt;Netflix&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;Link to="</span>/zillow-group<span class="string">"&gt;Zillow Group&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;Link to="</span>/yahoo<span class="string">"&gt;Yahoo&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;Link to="</span>/modus-create<span class="string">"&gt;Modus Create&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;Match pattern="</span>/:id<span class="string">" component=&#123;Child&#125; /&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/Router&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>不过这样的变动将会导致一个很严重的问题：由于路由定义里不再是纯粹的路由相关的组件，你无法在一个文件中（通常是用来定义路由的 <code>routes.js</code>）看到整个 App 的路由设计及分布。</strong></p>
<p>目前 ReactRouter 提供了一个<a href="https://github.com/ReactTraining/react-router-addons-routes" target="_blank" rel="noopener">工具库</a>来解决将完整的路由定义转换为 <code>&lt;Match&gt;</code> 组件的问题，但是粗略的看了一下用法感觉还是比较别扭，期待正式发布时能有更好的解决方案。</p>
<h3 id="再见-lt-Route-gt-，你好-lt-Match-gt"><a href="#再见-lt-Route-gt-，你好-lt-Match-gt" class="headerlink" title="再见 &lt;Route&gt;，你好&lt;Match&gt;"></a>再见 &lt;Route&gt;，你好&lt;Match&gt;</h3><p>ReactRouter 中被使用最多的 <code>&lt;Route&gt;</code> 组件这次没有幸免，取而代之的是 <code>&lt;Match&gt;</code> 组件。那么 <code>&lt;Match&gt;</code> 究竟有什么不同呢？</p>
<p>1. <code>pattern</code> 取代 <code>path</code></p>
<p>很大程度上这只是为了配合 Match 这个名称的转换而已，实际功能与 path 无异。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Match pattern=<span class="string">"/users/:id"</span> component=&#123;User&#125;/&gt;</span><br></pre></td></tr></table></figure>
<p>2. <code>component</code> 还是 <code>component</code>，<code>components</code> 没了</p>
<p>判断路由命中时该渲染哪个组件的 props 还是叫 <code>component</code>，但是为一个路由同时提供多个命名组件的 props <code>components</code> 没有了。下文会详细介绍在 ReactRouter 中如何解决一个路由下渲染多个组件的问题。</p>
<p>3. 使用 <code>render</code> 渲染行内路由组件</p>
<p>能够更自由的控制当前命中组件的渲染，以及可以方便的添加进出的动画。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// convenient inline rendering</span></span><br><span class="line">&lt;Match pattern=<span class="string">"/home"</span> render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrapping/composing</span></span><br><span class="line"><span class="keyword">const</span> MatchWithFade = <span class="function">(<span class="params">&#123; component:Component, ...rest &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;Match &#123;...rest&#125; render=&#123;(matchProps) =&gt; (</span><br><span class="line">    &lt;FadeIn&gt;</span><br><span class="line">      &lt;Component &#123;...matchProps&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/FadeIn&gt;</span></span><br><span class="line"><span class="regexp">  )&#125;/</span>&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&lt;MatchWithFade pattern=<span class="string">"/cool"</span> component=&#123;Something&#125;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="lt-Miss-gt-取代曾经的-lt-NotFoundRoute-gt"><a href="#lt-Miss-gt-取代曾经的-lt-NotFoundRoute-gt" class="headerlink" title="&lt;Miss&gt; 取代曾经的 &lt;NotFoundRoute&gt;"></a>&lt;Miss&gt; 取代曾经的 &lt;NotFoundRoute&gt;</h3><p>早在 0.x 时代，ReactRouter 提供了 <code>&lt;NotFountRoute&gt;</code> 来解决渲染 404 页面的问题。不过这一组件在 <code>1.x</code> 时就被移除了，你不得不多写若干行代码来解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果想要展示一个 404 页面（当前 URL 不变）</span></span><br><span class="line">&lt;Route path=<span class="string">'*'</span> component=&#123;My404Component&#125; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想要展示一个 404 页面（当前 URL 重定向到 /404 ）</span></span><br><span class="line">&lt;Route path=<span class="string">'/404'</span> component=&#123;My404Component&#125; /&gt;</span><br><span class="line">&lt;Redirect <span class="keyword">from</span>=<span class="string">'*'</span> to=<span class="string">'/404'</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>在 ReactRouter 4 中，你可以省点儿事直接用 <code>&lt;Miss&gt;</code> 组件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Match pattern=<span class="string">"/foo"</span>/&gt;</span><br><span class="line">    &lt;Match pattern=<span class="string">"/bar"</span>/&gt;</span><br><span class="line">    &lt;Miss component=&#123;NoMatch&#125;/&gt;</span><br><span class="line">  &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const NoMatch = (&#123; location &#125;) =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;Nothing matched &#123;location.pathname&#125;.&lt;/</span>div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="ReactRouter-4-的大杀器：一个路由，多次匹配"><a href="#ReactRouter-4-的大杀器：一个路由，多次匹配" class="headerlink" title="ReactRouter 4 的大杀器：一个路由，多次匹配"></a>ReactRouter 4 的大杀器：一个路由，多次匹配</h2><p>在上文中我们提到过，目前 ReactRouter 匹配到某个路由时，将直接渲染通过 <code>component</code> 定义的组件，并把命中的子路由对应的组件作为 <code>this.props.children</code> 传入。</p>
<p>在前端 App 日益复杂的今天，一条路由的改变不仅仅简单的是页面的切换，甚至可能精细到页面上某些组件的切换。</p>
<p>让我们直接看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每条路由有两个组件，一个用于渲染 sidebar，一个用于渲染主页面</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">pattern</span>: <span class="string">'/'</span>,</span><br><span class="line">    exactly: <span class="literal">true</span>,</span><br><span class="line">    sidebar: <span class="function"><span class="params">()</span> =&gt;</span> &lt;div&gt;Home!&lt;/div&gt;,</span><br><span class="line">    main: <span class="function"><span class="params">()</span> =&gt;</span> &lt;h2&gt;Main&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  &#123; pattern: '/</span>foo<span class="string">',</span></span><br><span class="line"><span class="string">    sidebar: () =&gt; &lt;div&gt;foo!&lt;/div&gt;,</span></span><br><span class="line"><span class="string">    main: () =&gt; &lt;h2&gt;Foo&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &#123; pattern: '</span>/bar<span class="string">',</span></span><br><span class="line"><span class="string">    sidebar: () =&gt; &lt;div&gt;Bar!&lt;/div&gt;,</span></span><br><span class="line"><span class="string">    main: () =&gt; &lt;h2&gt;Bar&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;Router history=&#123;history&#125;&gt;</span></span><br><span class="line"><span class="string">  &lt;div className="page"&gt;</span></span><br><span class="line"><span class="string">    &lt;div className="sidebar"&gt;</span></span><br><span class="line"><span class="string">      &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="/foo"&gt;Foo&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;&lt;Link to="/bar"&gt;Bar&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;/ul&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      /* 对当前路由进行匹配，并渲染侧边栏 */</span></span><br><span class="line"><span class="string">      &#123;routes.map((route, index) =&gt; (</span></span><br><span class="line"><span class="string">        &lt;Match</span></span><br><span class="line"><span class="string">          key=&#123;index&#125;</span></span><br><span class="line"><span class="string">          pattern=&#123;route.pattern&#125;</span></span><br><span class="line"><span class="string">          component=&#123;route.sidebar&#125;</span></span><br><span class="line"><span class="string">          exactly=&#123;route.exactly&#125;</span></span><br><span class="line"><span class="string">        /&gt;</span></span><br><span class="line"><span class="string">      ))&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;div className="main"&gt;</span></span><br><span class="line"><span class="string">      /* 对当前路由进行匹配，并渲染主界面 */</span></span><br><span class="line"><span class="string">      &#123;routes.map((route, index) =&gt; (</span></span><br><span class="line"><span class="string">        &lt;Match</span></span><br><span class="line"><span class="string">          key=&#123;index&#125;</span></span><br><span class="line"><span class="string">          pattern=&#123;route.pattern&#125;</span></span><br><span class="line"><span class="string">          component=&#123;route.main&#125;</span></span><br><span class="line"><span class="string">          exactly=&#123;route.exactly&#125;</span></span><br><span class="line"><span class="string">        /&gt;</span></span><br><span class="line"><span class="string">      ))&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/Router&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过上面的代码片段我们可以看出，<code>&lt;Match&gt;</code> 的设计理念完全不同于 <code>&lt;Route&gt;</code>。使用 <code>&lt;Match&gt;</code> 可以让我们在当前路由中尽情的匹配并渲染需要的组件，无论是需要渲染 Sidebar、BreadCrumb 还是主界面。</p>
<p>若使用现有的 ReactRouter API，只能通过当前路由匹配主界面对应的组件，至于 Sidebar 和 BreadCrumb，只能传入当前的 pathname 手动进行匹配。由此可见 <code>&lt;Match&gt;</code> 将会为此类需求带来极大的便利。</p>
<h2 id="其他疑惑"><a href="#其他疑惑" class="headerlink" title="其他疑惑"></a>其他疑惑</h2><p>当然，还有几个大家普遍关心的问题官方文档中也有所提及：</p>
<p>1. ReactRouter 的 API 是否还会有大的变化？</p>
<p>答：只要 React 的 API 不变，这一版的 API 也不会变。</p>
<p>2. 是否有对 Redux 的支持？</p>
<p>答：将提供一个受控的 <code>&lt;ControlledRouter&gt;</code>，支持传入一个 location。（作者注：这下真的不需要 react-router-redux 了，撒花！）</p>
<p>3. 新版是否对滚动位置管理添加支持？</p>
<p>答：将会对 <code>window</code> 和独立组件的滚动位置提供管理功能。（作者注：目前在不添加额外配置的情况下，路由切换时并不会恢复滚动位置）</p>
<h2 id="ReactRouter-4-小结"><a href="#ReactRouter-4-小结" class="headerlink" title="ReactRouter 4 小结"></a>ReactRouter 4 小结</h2><p>了解了这么多 ReactRouter 4 的内容，你是否喜欢新版的 API 设计呢？</p>
<p>其实从 ReactRouter 4 的这些变动不难看出，ReactRouter 正在努力的朝纯声明式的 API 方向迈进，一方面减少不必要的命令式 API，一方面也提供更语义化的路由匹配方案。</p>
<p>此外新的 ReactRouter 也提供了非常强大的动态路由能力，甚至对嵌套路由也有所支持，这也是一个复杂的前端应用所必须的功能。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://react-router-website-xvufzcovng.now.sh/" target="_blank" rel="noopener">ReactRouter 4 文档</a></li>
<li><a href="https://github.com/ReactTraining/react-router/tree/v4" target="_blank" rel="noopener">ReactRouter 4 Github repo</a></li>
<li><a href="https://github.com/ReactTraining/react-router" target="_blank" rel="noopener">ReactRouter</a></li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>

  
	<section id="comments" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'undefinedblog';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>





    </main>

    <footer class="site-footer">
  <p class="site-info">
    Powered by <a href="https://hexo.io/" target="_blank" rel="nofollow">Hexo</a> and
    Theme adapted from <a href="https://github.com/CodeDaraW/Hacker" target="_blank" rel="nofollow">Hacker</a>
    <br />
    
    &copy; 2018 jasonslyvia
    
  </p>
</footer>

    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-50332938-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>
